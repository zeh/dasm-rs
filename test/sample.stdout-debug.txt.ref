Debug trace ON
char '0'
stackarg 0 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;   FATROM.ASM

0MEMORYADDR0 		;

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			MEMORY MAP	 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		;   We throw away some internal ram (96 bytes) in order

0MEMORYADDR0 		;   to use direct addressing for the majority of memory

0MEMORYADDR0 		;   accesses by mapping the registers at 0.

0MEMORYADDR0 		;

0MEMORYADDR0 		;   MC68HC11F1 port and bit assignments

0MEMORYADDR0 		;

0MEMORYADDR0 		;   We setup a very fast OC1 interrupt.. around 208uS, to

0MEMORYADDR0 		;   handle main system timing.  This also allows us to have

0MEMORYADDR0 		;   a WAI instruction in our serial poll loop to lower power

0MEMORYADDR0 		;   consumption.

0MEMORYADDR0 

0MEMORYADDR0 RAM		equ	$0000		;   1K byte of RAM

char '$'
stackarg 0 (@0)
0MEMORYADDR0 LORAMBEG	equ	$0060		;   96 unusable due to ctl regs

char '$'
stackarg 96 (@0)
0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 HIRAMBEG	equ	$0300		;   hardwired for RTU software

char '$'
stackarg 768 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 HIRAMBEG	equ	$0320

0MEMORYADDR0 	       eif

0MEMORYADDR0 REGS		equ	$0000		;   96 control regs (after INIT)

char '$'
stackarg 0 (@0)
0MEMORYADDR0 EEPROM		equ	$FE00		;   512 bytes EEPROM

char '$'
stackarg 65024 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTA		equ	REGS+$00	;   i/o port A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 0 (@1)
evaltop @(A,O) 2 1
stackarg 0 (@0)
0MEMORYADDR0 PORTA_24V	equ	$80		;   24V power switch

char '$'
stackarg 128 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRA		equ	REGS+$01	;

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTG		equ	REGS+$02

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 2 (@0)
0MEMORYADDR0 CSPROG		equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 CSGEN		equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 CS101		equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 CS102		equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PORTG_RESERVED7 equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PORTG_MUXSEL3	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PORTG_MUXSEL2	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 PORTG_MUXSEL1	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PORTG_MUXSEL0	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 PORTG_ADSTROBHI equ	$04

char '$'
stackarg 4 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRG		equ	REGS+$03

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 3 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTB		equ	REGS+$04	;   i/o port B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 4 (@1)
evaltop @(A,O) 2 1
stackarg 4 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTF		equ     REGS+$05	;   PORTF l.e.d's and digout 1 & 2

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 5 (@1)
evaltop @(A,O) 2 1
stackarg 5 (@0)
0MEMORYADDR0 PORTF_DIGOUT2	equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PORTF_DIGOUT1	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PORTF_GRN	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 PORTF_RED	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTC		equ	REGS+$06

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 6 (@1)
evaltop @(A,O) 2 1
stackarg 6 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRC		equ	REGS+$07

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 7 (@1)
evaltop @(A,O) 2 1
stackarg 7 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTD		equ	REGS+$08

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 8 (@1)
evaltop @(A,O) 2 1
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRD		equ	REGS+$09

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 9 (@1)
evaltop @(A,O) 2 1
stackarg 9 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTE		equ	REGS+$0A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 10 (@1)
evaltop @(A,O) 2 1
stackarg 10 (@0)
0MEMORYADDR0 

0MEMORYADDR0 CFORC		equ	REGS+$0B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 11 (@1)
evaltop @(A,O) 2 1
stackarg 11 (@0)
0MEMORYADDR0 CFORC_FOC1	equ	$80	; FORCE OUTPUT COMPARE 1-4

char '$'
stackarg 128 (@0)
0MEMORYADDR0 CFORC_FOC2	equ	$40	;	....OR'D WITH TOC'S

char '$'
stackarg 64 (@0)
0MEMORYADDR0 CFORC_FOC3	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 CFORC_FOC4	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 CFORC_FOC5	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OC1M		equ	REGS+$0C	; OUTPUT COMPARE MASK

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 12 (@1)
evaltop @(A,O) 2 1
stackarg 12 (@0)
0MEMORYADDR0 OC1_M7		equ	$80	; ALLOWS COUNTER COMPARE OUTPUTS ESTABLISHED BY

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OC1_M6		equ	$40	; OC1D6-D3 ON PA

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OC1_M5		equ	$20	;   EXCEPT FOR OC1M7 WHICH ALLOWS EITHER

char '$'
stackarg 32 (@0)
0MEMORYADDR0 OC1_M4		equ	$10	; INTERNAL DATA (0) OR OC1D7 DURING WRITES TO

char '$'
stackarg 16 (@0)
0MEMORYADDR0 OC1_M3		equ	$08	; PA7

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OC1D		equ	REGS+$0D

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 13 (@1)
evaltop @(A,O) 2 1
stackarg 13 (@0)
0MEMORYADDR0 OC1_d7		equ	$80	; STATES WHICH WILL BE PRESENT ON PA6-PA3

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OC1_d6		equ	$40	; WHEN PERMITTED BY OC1_M6-M3

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OC1_d5		equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 OC1_d4		equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 OC1_d3		equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TCNT		equ	REGS+$0E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 14 (@1)
evaltop @(A,O) 2 1
stackarg 14 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TIC1		equ	REGS+$10

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 16 (@1)
evaltop @(A,O) 2 1
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TIC2		equ	REGS+$12

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 18 (@1)
evaltop @(A,O) 2 1
stackarg 18 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TIC3		equ	REGS+$14

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 20 (@1)
evaltop @(A,O) 2 1
stackarg 20 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC1		equ	REGS+$16

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 22 (@1)
evaltop @(A,O) 2 1
stackarg 22 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC2		equ	REGS+$18

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 24 (@1)
evaltop @(A,O) 2 1
stackarg 24 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC3		equ	REGS+$1A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 26 (@1)
evaltop @(A,O) 2 1
stackarg 26 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC4		equ	REGS+$1C

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 28 (@1)
evaltop @(A,O) 2 1
stackarg 28 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC5		equ	REGS+$1E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 30 (@1)
evaltop @(A,O) 2 1
stackarg 30 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TCTL1		equ	REGS+$20	;ACTION TAKEN CODES  M	L

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 32 (@1)
evaltop @(A,O) 2 1
stackarg 32 (@0)
0MEMORYADDR0 TCTL1_OM2	equ	$80	;		     0	0 -DISABLE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TCTL1_OL2	equ	$40	;		     0	1 -TOGGLE

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TCTL1_OM3	equ	$20	;		     1	0 -CLEAR

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TCTL1_OL3	equ	$10	;		     1	1 -SET

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TCTL1_OM4	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TCTL1_OL4	equ	$04	;  OR, WHAT 1 OF 4 THINGS HAPPEN TO OUT.CMP

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TCTL1_OM5	equ	$02	;  FLAGS IN TFLG1 2-5 (OCF'S 2-5)

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TCTL1_OL5	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TCTL2		equ	REGS+$21	; B  A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 33 (@1)
evaltop @(A,O) 2 1
stackarg 33 (@0)
0MEMORYADDR0 TCTL2_EDG1B	equ	$20	; 0  0 CAPTURE DISABLED

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TCTL2_EDG1A	equ	$10	; 0  1	 ''    ON RISING

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TCTL2_EDG2B	equ	$08	; 1  0   ''      ON FALLING

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TCTL2_EDG2A	equ	$04	; 1  1   ''    ON ANY

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TCTL2_EDG3B	equ	$02

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TCTL2_EDG3A	equ	$01

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TMSK1		equ	REGS+$22

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 34 (@1)
evaltop @(A,O) 2 1
stackarg 34 (@0)
0MEMORYADDR0 TMSK1_OC1I	equ	$80	;

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TMSK1_OC2I	equ	$40	; ENABLE OUTPUT COMPARE INTERRUPT WHEN SET

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TMSK1_OC3I	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TMSK1_OC4I	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TMSK1_OC5I	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TMSK1_IC1I	equ	$04	; ENABLE INTERUPTS ON CAPTURE FLAG WHEN SET

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TMSK1_IC2I	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TMSK1_IC3I	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TFLG1		equ	REGS+$23

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 35 (@1)
evaltop @(A,O) 2 1
stackarg 35 (@0)
0MEMORYADDR0 TFLG1_OC1F	equ	$80	; CORRESPONDING FLAGS TO THE ABOVE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TFLG1_OC2F	equ	$40	;

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TFLG1_OC3F	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TFLG1_OC4F	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TFLG1_OC5F	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TFLG1_IC1F	equ	$04	;

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TFLG1_IC2F	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TFLG1_IC3F	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;NOTE: PR1 & PR0 MUST BE WRITTEN IMMEDIATELY AFTER RESET!!

0MEMORYADDR0 

0MEMORYADDR0 TMSK2		equ	REGS+$24

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 36 (@1)
evaltop @(A,O) 2 1
stackarg 36 (@0)
0MEMORYADDR0 TMSK2_TOI	equ	$80	; Timer overflow interrupt enable

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TMSK2_RTII	equ	$40	; Real time interrupt

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TMSK2_PAOVI	equ	$20	; Pulse accumulator overflow

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TMSK2_PAII	equ	$10	; Pulse accumulator count

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TMSK2_PR1	equ	$02	; Timer prescale select

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TMSK2_PR0	equ	$01	;  0,0=/1  0,1=/4  1,0=/8  1,1=/16

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 TFLG2		equ	REGS+$25

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 37 (@1)
evaltop @(A,O) 2 1
stackarg 37 (@0)
0MEMORYADDR0 TFLG2_TOF	equ	$80	; FLAGS FOR THE ABOVE 1ST 4 INTERRUPTS

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TFLG2_RTIF	equ	$40	;

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TFLG2_PAOVF	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TFLG2_PAIF	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 PACTL		equ	REGS+$26

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 38 (@1)
evaltop @(A,O) 2 1
stackarg 38 (@0)
0MEMORYADDR0 PACTL_DDRA7	equ	$80	; 0=INPUT ONLY, 1=OUTPUT

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PACTL_PAEN	equ	$40	; ENABLE PA

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PACTL_PAMOD	equ	$20	; 0=COUNT EXTERNAL EVENTS,1=GATED TIME ACCUM.

char '$'
stackarg 32 (@0)
0MEMORYADDR0 PACTL_PEDGE	equ	$10	; 0=INC ON FALLING OR INHIBITS CNT;1=OPPOSITE

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PACTL_RTR1	equ	$02 	; Divider for real time interrupt

char '$'
stackarg 2 (@0)
0MEMORYADDR0 PACTL_RTR0	equ	$01 	; Divide by 2^13, 2^14, 2^15, or 2^16

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 PACNT		equ	REGS+$27

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 39 (@1)
evaltop @(A,O) 2 1
stackarg 39 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SPCR		equ	REGS+$28

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 40 (@1)
evaltop @(A,O) 2 1
stackarg 40 (@0)
0MEMORYADDR0 SPCR_SPIE	equ	$80	; serial PERIPH INTERRUPT ENABLE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SPCR_SPE	equ	$40	; serial periph system enable

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SPCR_DWOM	equ	$20	; PORT D WIRED-OR 0=TOTEM,1=OPEN DRAIN

char '$'
stackarg 32 (@0)
0MEMORYADDR0 SPCR_MSTR	equ	$10	; 0=SLAVE, 1=MASTER

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SPCR_CPOL	equ	$08	; 0=ACT. HIGH CLKS;SCK IDLES LOW--1 IS OPPOSITE

char '$'
stackarg 8 (@0)
0MEMORYADDR0 SPCR_CPHA	equ	$04	; CLOCK PHASE

char '$'
stackarg 4 (@0)
0MEMORYADDR0 SPCR_SPR1	equ	$02	;	  E CLOCK /  2	 4   16   32

char '$'
stackarg 2 (@0)
0MEMORYADDR0 SPCR_SPR0	equ	$01	;		     00  01  10   11

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SPSR		equ	REGS+$29

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 41 (@1)
evaltop @(A,O) 2 1
stackarg 41 (@0)
0MEMORYADDR0 SPSR_SPIF	equ	$80	; TXFR COMPLETE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SPSR_WCOL	equ	$40	; WRITE COLLISION

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SPSR_MODF	equ	$10	; MODE-FAULT ERROR FLAG

char '$'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SPDR		equ	REGS+$2A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 42 (@1)
evaltop @(A,O) 2 1
stackarg 42 (@0)
0MEMORYADDR0 

0MEMORYADDR0 BAUD		equ	REGS+$2B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 43 (@1)
evaltop @(A,O) 2 1
stackarg 43 (@0)
0MEMORYADDR0 BAUD_TCLR	equ	$80 	; 0

char '$'
stackarg 128 (@0)
0MEMORYADDR0 BAUD_SCP1	equ	$20 	; divide e by 1  3  4   13

char '$'
stackarg 32 (@0)
0MEMORYADDR0 BAUD_SCP0	equ	$10 	;	      00 01 10  11

char '$'
stackarg 16 (@0)
0MEMORYADDR0 BAUD_RCKB	equ	$08 	; 0

char '$'
stackarg 8 (@0)
0MEMORYADDR0 BAUD_SCR2	equ	$04 	; divide prescaler out by 1,  2   4,.....128

char '$'
stackarg 4 (@0)
0MEMORYADDR0 BAUD_SCR1	equ	$02 	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 BAUD_SCR0	equ	$01 	; scr0,1,2 =    000 001 010.....111

char '$'
stackarg 1 (@0)
0MEMORYADDR0 BAUD_4800	equ	BAUD_SCP1|BAUD_SCR1

char 'B'
stackarg 32 (@0)
char '|'
doop
doop @ 0 unary
char 'B'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 34 (@0)
0MEMORYADDR0 BAUD_9600	equ	BAUD_SCR0|BAUD_SCR1

char 'B'
stackarg 1 (@0)
char '|'
doop
doop @ 0 unary
char 'B'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 3 (@0)
0MEMORYADDR0 BAUD_19200	equ	BAUD_SCR1

char 'B'
stackarg 2 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 SCCR1		equ	REGS+$2C

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 44 (@1)
evaltop @(A,O) 2 1
stackarg 44 (@0)
0MEMORYADDR0 SCCR1_R8	equ	$80 	; get the ninth bit here, if 'M' bit is set

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SCCR1_T8	equ	$40	; set this bit for the 9th tx bit if 'M' is set

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SCCR1_M 	equ	$10	; 'M'

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SCCR1_WAKE	equ	$08	; 0=idle line, 1=address mark

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SCCR2		equ	REGS+$2D

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 45 (@1)
evaltop @(A,O) 2 1
stackarg 45 (@0)
0MEMORYADDR0 SCCR2_TIE	equ	$80	; Transmit interrupt enable

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SCCR2_TCIE	equ	$40	; Transmit Complete interr en

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SCCR2_RIE	equ	$20	; Receiver Interrupt enable

char '$'
stackarg 32 (@0)
0MEMORYADDR0 SCCR2_ILIE	equ	$10	; Idle Line ''       ''

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SCCR2_TE	equ	$08	; tx enable

char '$'
stackarg 8 (@0)
0MEMORYADDR0 SCCR2_RE	equ	$04	; rx """

char '$'
stackarg 4 (@0)
0MEMORYADDR0 SCCR2_RWU	equ	$02	; wake up when set

char '$'
stackarg 2 (@0)
0MEMORYADDR0 SCCR2_SBK	equ	$01	; send break

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 SCSR		equ	REGS+$2E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 46 (@1)
evaltop @(A,O) 2 1
stackarg 46 (@0)
0MEMORYADDR0 SCSR_TDRE	equ	$80	; Transmit Data Register Empty

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SCSR_TC 	equ	$40	; Transmit Complete

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SCSR_RDRF	equ	$20	; Receiver Data Ready

char '$'
stackarg 32 (@0)
0MEMORYADDR0 SCSR_IDLE	equ	$10	; Idle Line Detect

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SCSR_OR 	equ	$08	; overrun error

char '$'
stackarg 8 (@0)
0MEMORYADDR0 SCSR_NF 	equ	$04	; noise flag

char '$'
stackarg 4 (@0)
0MEMORYADDR0 SCSR_FE 	equ	$02	; framing error

char '$'
stackarg 2 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 SCDR		equ	REGS+$2F	; sc data reg

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 47 (@1)
evaltop @(A,O) 2 1
stackarg 47 (@0)
0MEMORYADDR0 

0MEMORYADDR0 ADCTL		equ	REGS+$30

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 48 (@1)
evaltop @(A,O) 2 1
stackarg 48 (@0)
0MEMORYADDR0 ADCTL_CCF	equ	$80 	; Conversion complete, cleared on ADCTL write

char '$'
stackarg 128 (@0)
0MEMORYADDR0 ADCTL_SCAN	equ	$20	; Continuous scan mode, else single scan

char '$'
stackarg 32 (@0)
0MEMORYADDR0 ADCTL_MULT	equ	$10	; Scan all four channels or just one channel

char '$'
stackarg 16 (@0)
0MEMORYADDR0 ADCTL_CD	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 ADCTL_CC	equ	$04	;

char '$'
stackarg 4 (@0)
0MEMORYADDR0 ADCTL_CB	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 ADCTL_CA	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 ADR1		equ	REGS+$31	; ADC register 1

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 49 (@1)
evaltop @(A,O) 2 1
stackarg 49 (@0)
0MEMORYADDR0 ADR2		equ	REGS+$32

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 50 (@1)
evaltop @(A,O) 2 1
stackarg 50 (@0)
0MEMORYADDR0 ADR3		equ	REGS+$33

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 51 (@1)
evaltop @(A,O) 2 1
stackarg 51 (@0)
0MEMORYADDR0 ADR4		equ	REGS+$34

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 52 (@1)
evaltop @(A,O) 2 1
stackarg 52 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 BPROT		equ	REGS+$35

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 53 (@1)
evaltop @(A,O) 2 1
stackarg 53 (@0)
0MEMORYADDR0 BPROT_PTCON	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 BPROT_BPRT3	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 BPROT_BPRT2	equ	$04

char '$'
stackarg 4 (@0)
0MEMORYADDR0 BPROT_BPRT1	equ	$02

char '$'
stackarg 2 (@0)
0MEMORYADDR0 BPROT_BPRT0	equ	$01

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OPT2		equ	REGS+$38	; config options 2 register

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 56 (@1)
evaltop @(A,O) 2 1
stackarg 56 (@0)
0MEMORYADDR0 OPT2_GWOM	equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OPT2_CWOM	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OPT2_CLK4X	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OPTION		equ	REGS+$39

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 57 (@1)
evaltop @(A,O) 2 1
stackarg 57 (@0)
0MEMORYADDR0 OPTION_ADPU	equ	$80	; A/D power

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OPTION_CSEL	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OPTION_IRQE	equ	$20	; IRQ edge sensitive enable, else level sens.

char '$'
stackarg 32 (@0)
0MEMORYADDR0 OPTION_DLY	equ	$10	; delay 4000 E clks after stop, else 4

char '$'
stackarg 16 (@0)
0MEMORYADDR0 OPTION_CME	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 OPTION_CR1	equ	$02	; cop timer rates of E/2^15/(1,4,16,64)

char '$'
stackarg 2 (@0)
0MEMORYADDR0 OPTION_CR0	equ	$01	; for 00,01,10,11

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 COPRST		equ	REGS+$3A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 58 (@1)
evaltop @(A,O) 2 1
stackarg 58 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; EEPROM programming register.

0MEMORYADDR0 		;

0MEMORYADDR0 		; BYTE ROW	(only valid when erase bit is set)

0MEMORYADDR0 		;  0    0	bulk erase

0MEMORYADDR0 		;  0	1	row erase

0MEMORYADDR0 		;  1	0	byte erase

0MEMORYADDR0 		;  1	1	byte erase

0MEMORYADDR0 		;

0MEMORYADDR0 		; erase sequence is:

0MEMORYADDR0 		;	+BYTE+ERASE+EELAT, write eeprom, +PGM, delay 10 ms,

0MEMORYADDR0 		;	-PGM-ERASE-EELAT

0MEMORYADDR0 		; program sequence is:  

0MEMORYADDR0 		;	+EELAT, write eeprom, +PGM, delay 10 ms, -PGM-EELAT

0MEMORYADDR0 		;

0MEMORYADDR0 		; you do not need to program to zero before erasing to 1's.

0MEMORYADDR0 

0MEMORYADDR0 PPROG		equ	REGS+$3B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 59 (@1)
evaltop @(A,O) 2 1
stackarg 59 (@0)
0MEMORYADDR0 PPROG_ODD	equ	$80	; Factory reserved

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PPROG_EVEN	equ	$40	; Factory reserved

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PPROG_BYTE	equ	$10	; Byte erase mode

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PPROG_ROW	equ	$08	; Row erase mode

char '$'
stackarg 8 (@0)
0MEMORYADDR0 PPROG_ERASE	equ	$04	; Erase enable

char '$'
stackarg 4 (@0)
0MEMORYADDR0 PPROG_EELAT	equ	$02	; arm eeprom write (then write to eeprom)

char '$'
stackarg 2 (@0)
0MEMORYADDR0 PPROG_EEPGM	equ	$01	; apply programming voltage

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 HPRIO		equ	REGS+$3C

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 60 (@1)
evaltop @(A,O) 2 1
stackarg 60 (@0)
0MEMORYADDR0 HPRIO_RBOOT	equ	$80	; Set in special test mode

char '$'
stackarg 128 (@0)
0MEMORYADDR0 HPRIO_SMOD	equ	$40	; ~MODB pin latched at reset

char '$'
stackarg 64 (@0)
0MEMORYADDR0 HPRIO_MDA	equ	$20	; MODB pin latched at reset, can be clrd in

char '$'
stackarg 32 (@0)
0MEMORYADDR0 				; special tes/tbootstrap mode ?

0MEMORYADDR0 HPRIO_IRV	equ	$10	; internal read visibility

char '$'
stackarg 16 (@0)
0MEMORYADDR0 HPRIO_PSEL3	equ	$08	; Select highest priority interrupt, only

char '$'
stackarg 8 (@0)
0MEMORYADDR0 HPRIO_PSEL2	equ	$04	; writable when interrupts are masked.

char '$'
stackarg 4 (@0)
0MEMORYADDR0 HPRIO_PSEL1	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 HPRIO_PSEL0	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 INIT		equ	REGS+$3D

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 61 (@1)
evaltop @(A,O) 2 1
stackarg 61 (@0)
0MEMORYADDR0 INIT_RAM3	equ	$80	; Internal ram base address in 4K chunks,

char '$'
stackarg 128 (@0)
0MEMORYADDR0 INIT_RAM2	equ	$40	; default $0000 (0000)

char '$'
stackarg 64 (@0)
0MEMORYADDR0 INIT_RAM1	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 INIT_RAM0	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 INIT_REG3	equ	$08	; Control register base address in 4K chunks,

char '$'
stackarg 8 (@0)
0MEMORYADDR0 INIT_REG2	equ	$04	; default $1000 (0001)

char '$'
stackarg 4 (@0)
0MEMORYADDR0 INIT_REG1	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 INIT_REG0	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TEST1		equ	REGS+$3E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 62 (@1)
evaltop @(A,O) 2 1
stackarg 62 (@0)
0MEMORYADDR0 TEST1_TILOP	equ	$80	; FACTORY TEST STUFF ONLY WHEN SMOD=1

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TEST1_OCCR	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TEST1_CBYP	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TEST1_DISR	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TEST1_FCM	equ	$04

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TEST1_FCOP	equ	$02

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TEST1_TCON	equ	$01

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 CONFIG		equ	REGS+$3F

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 63 (@1)
evaltop @(A,O) 2 1
stackarg 63 (@0)
0MEMORYADDR0 CONFIG_NOSEC	equ	$08	; no eeprom security

char '$'
stackarg 8 (@0)
0MEMORYADDR0 CONFIG_NOCOP	equ	$04	; no hardware watchdog

char '$'
stackarg 4 (@0)
0MEMORYADDR0 CONFIG_ROMON	equ	$02	; enable rom

char '$'
stackarg 2 (@0)
0MEMORYADDR0 CONFIG_EEON	equ	$01	; enable eeprom

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; In bootstrap mode vectors go through ram

0MEMORYADDR0 		; 

0MEMORYADDR0 

0MEMORYADDR0 BsSCIJmp	equ	$C4

char '$'
stackarg 196 (@0)
0MEMORYADDR0 BsSPIJmp	equ	$C7

char '$'
stackarg 199 (@0)
0MEMORYADDR0 BsPAIJmp	equ	$CA

char '$'
stackarg 202 (@0)
0MEMORYADDR0 BsPAOVJmp	equ	$CD

char '$'
stackarg 205 (@0)
0MEMORYADDR0 BsTOVJmp	equ	$D0

char '$'
stackarg 208 (@0)
0MEMORYADDR0 BsOC5Jmp	equ	$D3

char '$'
stackarg 211 (@0)
0MEMORYADDR0 BsOC4Jmp	equ	$D6

char '$'
stackarg 214 (@0)
0MEMORYADDR0 BsOC3Jmp	equ	$D9

char '$'
stackarg 217 (@0)
0MEMORYADDR0 BsOC2Jmp	equ	$DC

char '$'
stackarg 220 (@0)
0MEMORYADDR0 BsOC1Jmp	equ	$DF

char '$'
stackarg 223 (@0)
0MEMORYADDR0 BsIC3Jmp	equ	$E2

char '$'
stackarg 226 (@0)
0MEMORYADDR0 BsIC2Jmp	equ	$E5

char '$'
stackarg 229 (@0)
0MEMORYADDR0 BsIC1Jmp	equ	$E8

char '$'
stackarg 232 (@0)
0MEMORYADDR0 BOOTSTRAPORG	equ	$EB	; bootstrap origin

char '$'
stackarg 235 (@0)
0MEMORYADDR0 BsRTIJmp	equ	$EB

char '$'
stackarg 235 (@0)
0MEMORYADDR0 BsIRQJmp	equ	$EE

char '$'
stackarg 238 (@0)
0MEMORYADDR0 BsXIRQJmp	equ	$F1

char '$'
stackarg 241 (@0)
0MEMORYADDR0 BsSWIJmp	equ	$F4

char '$'
stackarg 244 (@0)
0MEMORYADDR0 BsILLJmp	equ	$F7

char '$'
stackarg 247 (@0)
0MEMORYADDR0 BsCOPJmp	equ	$FA

char '$'
stackarg 250 (@0)
0MEMORYADDR0 BsCMJmp		equ	$FD

char '$'
stackarg 253 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		processor 68hc11

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			RAM VARS 	 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; most/all ram variables can be accessed with direct

0MEMORYADDR0 		; addressing for the EEPROM version.

0MEMORYADDR0 

0MEMORYADDR0 		seg.u	bss

0MEMORYADDR0 		org	LORAMBEG

char 'L'
stackarg 96 (@0)
0MEMORYADDR0 

0MEMORYADDR0 RTUConfig	ds.b	1	; RTU Flags reg, cleared on reset

char '1'
stackarg 1 (@0)
0MEMORYADDR0 BoardAddr	ds.b	1	; 1 byte board address

char '1'
stackarg 1 (@0)
0MEMORYADDR0 Counter1	ds.w	1	; 2 bytes counter input

char '1'
stackarg 1 (@0)
0MEMORYADDR0 Counter2	ds.w	1	; 2 bytes counter input

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIRedCnt	ds.b	1	; real time interrupt red l.e.d. countdown

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIGrnCnt	ds.b	1	; real time interrupt grn l.e.d. countdown

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIWDog		ds.w	1	; 2 byte wdog ctr, reset by packet reception

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIAvrCnt	ds.b	1	; 1 16 sample countdown

char '1'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; note: packet size for ram-dl version must be smaller so

0MEMORYADDR0 		; program fits in ram

0MEMORYADDR0 

0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 PacketBuf	ds.b	256+8	; maximum packet size plus slop

char '2'
stackarg 256 (@0)
char '+'
doop
doop @ 0 unary
char '8'
stackarg 8 (@1)
evaltop @(A,O) 2 1
stackarg 264 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 PacketBuf	ds.b	32+8	; maximum packet size plus slop in bootstrap

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 		; note: MaxScanTable location hardwired by ioscan for normal

0MEMORYADDR0 		; operation

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		org	HIRAMBEG

char 'H'
stackarg 768 (@0)
0MEMORYADDR0 

0MEMORYADDR0 MaxScanTable	ds.b	96	; 16 channels x 3 (holdingregx1, accumulatorx2)

char '9'
stackarg 96 (@0)
0MEMORYADDR0 Stack		ds.b	64	; Reserve 64 bytes for the stack

char '6'
stackarg 64 (@0)
0MEMORYADDR0 StackEnd	ds.b	0

char '0'
stackarg 0 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			CODE SEGMENT		     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; For EEPROM version code starts at $FE00.  For RAM bootstrap

0MEMORYADDR0 		; version code starts at zero from which we immediately jump

0MEMORYADDR0 		; forward past all registers and ram variables

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		seg	code

0MEMORYADDR0 

0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		org	$FE00

char '$'
stackarg 65024 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 		org	$0000

0MEMORYADDR0 		jmp	Reset

0MEMORYADDR0 		org	BOOTSTRAPORG

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			ROM VARS 	 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Calibration constants are at the beginning of the rom,

0MEMORYADDR0 		; consisting of two 16 bit base constants for analog channel

0MEMORYADDR0 		; 1 and two 8 bit constants for each of analog channels

0MEMORYADDR0 		; 2 through 7, two 8 bit constants for the two temp.

0MEMORYADDR0 		; sensors, two 8 bit constants for the board temp. sensor.

0MEMORYADDR0 		;

0MEMORYADDR0 		; The RTU will interpret these constants

0MEMORYADDR0 

0MEMORYADDR0 		dc.w	$FFFF,$FFFF	; Mux channel 0, 4 and 20mA	AI01

char '$'
stackarg 65535 (@0)
char ','
char '$'
stackarg 65535 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 1 (delta)		AI02

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 2 (delta)		AI03

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 3 (delta)		AI04

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 4 (delta) (unused)

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 5 (delta)		AI05

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 6 (delta)		AI06

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 7 (delta)		AI07

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; External temp. sensor 1

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; External temp. sensor 2

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; On-Board temp. sensor

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			RESET 		 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Platform reset.  Interrupts are disabled and the stack

0MEMORYADDR0 		; pointer is/becomes invalid.

0MEMORYADDR0 

0MEMORYADDR0 Reset		subroutine

0MEMORYADDR0 ResetCmd

0MEMORYADDR0 BadInt

0MEMORYADDR0 		; disable interrupts, setup protected control registers

0MEMORYADDR0 		;	INIT - relocate ram and hardware regs to 0

0MEMORYADDR0 		;	OPT2 - disable clk4x output (save power)

0MEMORYADDR0 		;	OPTION - enable ADC

0MEMORYADDR0 		;

0MEMORYADDR0 		; note: due to ram/regs overlap, first 96 bytes of ram

0MEMORYADDR0 		; is unaccessable.  For bootstrapped programs, the 

0MEMORYADDR0 		; jmp to Reset becomes unaccessable after it is executed.

0MEMORYADDR0 

0MEMORYADDR0 		sei

0MEMORYADDR0 		clra			; .A = 0

0MEMORYADDR0 		staa	INIT-REGS+$1000	; map ram & regs to base address 0

char 'I'
stackarg 61 (@0)
char '-'
doop
doop @ 0 unary
char 'R'
stackarg 0 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 61 (@0)
doop @ 0
char '$'
stackarg 4096 (@1)
evaltop @(A,O) 2 1
stackarg 4157 (@0)
0MEMORYADDR0 		staa	OPT2		; disable clk4x & C,G wire-or modes

char 'O'
stackarg 56 (@0)
0MEMORYADDR0 		staa	BPROT		; allow eeprom to be written

char 'B'
stackarg 53 (@0)
0MEMORYADDR0 		ldab	#OPTION_ADPU	; enable ADC

char '#'
char 'O'
stackarg 128 (@0)
0MEMORYADDR0 		stab	OPTION

char 'O'
stackarg 57 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; SETUP PORTS AND DDRS

0MEMORYADDR0 		;

0MEMORYADDR0 		;	    DDR	       DATA

0MEMORYADDR0 		; PORTA	 10000000    0xxxxxxx	(+24V power switch)

0MEMORYADDR0 		; PORTB  <OUTPUT>    11111111	(LED's)

0MEMORYADDR0 		; PORTC  00000000    xxxxxxxx

0MEMORYADDR0 		; PORTD  xx110000    xx00xxxx   (~ss, sck)

0MEMORYADDR0 		; PORTE  <INPUT>     xxxxxxxx	(addr h, l, brdid, temp)

0MEMORYADDR0 		; PORTF  <OUTPUT>    00111111	(digout, LED's)

0MEMORYADDR0 		; PORTG  11111100    000000xx	(filter, mux sel, startconv, 

0MEMORYADDR0 		;				digin)

0MEMORYADDR0 		; note: PD5 must be an output so as not to interfere with

0MEMORYADDR0 		; SPI ~SS hardware.

0MEMORYADDR0 		;

0MEMORYADDR0 		; NOTE: PORTA_24V is off (0) by default.  This is to prevent

0MEMORYADDR0 		; the RTU's isolated power supply from getting jerked around

0MEMORYADDR0 		; when several boards are in the system.  Analog and digital

0MEMORYADDR0 		; inputs will not be valid until the RTU turns on this line.

0MEMORYADDR0 		;

0MEMORYADDR0 		; NOTE: PORTD ~SS output must be set to 1 before configuring

0MEMORYADDR0 		; the SPI as a master (???)

0MEMORYADDR0 		;

0MEMORYADDR0 		; .A is still 0

0MEMORYADDR0 

0MEMORYADDR0 		lds	#DDRD

char '#'
char 'D'
stackarg 9 (@0)
0MEMORYADDR0 		ldab	#%00111000	; DDRD = 00111000

char '#'
char '%'
stackarg 56 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		pshb			; PORTD= 00111000

0MEMORYADDR0 		psha			; DDRC = 00000000

0MEMORYADDR0 		des			; RESERVED06

0MEMORYADDR0 		ldab	#$3F		; PORTF= 00111111

char '#'
char '$'
stackarg 63 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		ldab	#$FF		; PORTB= 11111111

char '#'
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		ldab	#%11111100	; DDRG = 11111100

char '#'
char '%'
stackarg 252 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		psha			; PORTG= 0

0MEMORYADDR0 		ldab	#PORTA_24V	; DDRA = PORTA_24V

char '#'
char 'P'
stackarg 128 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		psha			; PORTA= 0

0MEMORYADDR0 

0MEMORYADDR0 		; Setup remaining hardware, .A still 0

0MEMORYADDR0 		;

0MEMORYADDR0 		;	ADC	setup for continuous scan channels 4-7

0MEMORYADDR0 		;	SCI	9600bps 8N1, IDLE wake detection

0MEMORYADDR0 		;	SPI	Setup clock phase, etc..

0MEMORYADDR0 

0MEMORYADDR0 		ldab	#ADCTL_MULT|ADCTL_SCAN|ADCTL_CC

char '#'
char 'A'
stackarg 16 (@0)
char '|'
doop
doop @ 0 unary
char 'A'
stackarg 32 (@1)
char '|'
doop
evaltop @(A,O) 2 1
stackarg 48 (@0)
doop @ 0
char 'A'
stackarg 4 (@1)
evaltop @(A,O) 2 1
stackarg 52 (@0)
0MEMORYADDR0 		stab	ADCTL

char 'A'
stackarg 48 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		staa	SCCR1

char 'S'
stackarg 44 (@0)
0MEMORYADDR0 		ldab	#SCCR2_TE|SCCR2_RE

char '#'
char 'S'
stackarg 8 (@0)
char '|'
doop
doop @ 0 unary
char 'S'
stackarg 4 (@1)
evaltop @(A,O) 2 1
stackarg 12 (@0)
0MEMORYADDR0 		stab	SCCR2

char 'S'
stackarg 45 (@0)
0MEMORYADDR0 		ldab	#BAUD_9600

char '#'
char 'B'
stackarg 3 (@0)
0MEMORYADDR0 		stab	BAUD

char 'B'
stackarg 43 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; SPI, .A still 0

0MEMORYADDR0 		;

0MEMORYADDR0 		; CPOL=0, CPHA=0, clkrate= E/2 (614KHz)

0MEMORYADDR0 

0MEMORYADDR0 		ldab	#SPCR_MSTR	; make master, disable

char '#'
char 'S'
stackarg 16 (@0)
0MEMORYADDR0 		stab	SPCR

char 'S'
stackarg 40 (@0)
0MEMORYADDR0 		bset	SPCR,SPCR_SPE	; enable

char 'S'
stackarg 40 (@0)
char ','
char 'S'
stackarg 64 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; ICR - Input capture registers

0MEMORYADDR0 		;

0MEMORYADDR0 		; Setup input capture registers for counter inputs and setup

0MEMORYADDR0 		; OC1 to handle system timing.

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		bset	TCTL2,TCTL2_EDG1A|TCTL2_EDG2A|TCTL2_EDG3A

char 'T'
stackarg 33 (@0)
char ','
char 'T'
stackarg 16 (@0)
char '|'
doop
doop @ 0 unary
char 'T'
stackarg 4 (@1)
char '|'
doop
evaltop @(A,O) 2 1
stackarg 20 (@0)
doop @ 0
char 'T'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 21 (@0)
0MEMORYADDR0 		bset	TMSK1,TMSK1_IC1I|TMSK1_IC2I|TMSK1_OC1I

char 'T'
stackarg 34 (@0)
char ','
char 'T'
stackarg 4 (@0)
char '|'
doop
doop @ 0 unary
char 'T'
stackarg 2 (@1)
char '|'
doop
evaltop @(A,O) 2 1
stackarg 6 (@0)
doop @ 0
char 'T'
stackarg 128 (@1)
evaltop @(A,O) 2 1
stackarg 134 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; bootstrap interrupt vectors (.A still 0)

0MEMORYADDR0 		;

0MEMORYADDR0 		; When bootstrapping to ram, the 68HC11F1 implements pseudo

0MEMORYADDR0 		; vectors and we have to create a jump table for the vectors

0MEMORYADDR0 		; we use.

0MEMORYADDR0 

0MEMORYADDR0 	       ifnconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		ldab	#$7E		; JMP extended instruction

0MEMORYADDR0 		stab	BsOC1Jmp

0MEMORYADDR0 		stab    BsIC1Jmp

0MEMORYADDR0 		stab    BsIC2Jmp

0MEMORYADDR0 		ldx	#OC1Int		; address of OC1 interrupt

0MEMORYADDR0 		stx	BsOC1Jmp+1

0MEMORYADDR0 		ldx	#IC1Int

0MEMORYADDR0 		stx	BsIC1Jmp+1

0MEMORYADDR0 		ldx	#IC2Int

0MEMORYADDR0 		stx	BsIC2Jmp+1

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 		; Setup stack and various ram variables, .A still 0

0MEMORYADDR0 		;

0MEMORYADDR0 		; We do not have to clear RTIWDog since it is reset by packet

0MEMORYADDR0 		; reception and the relays are off anyway before then.  We

0MEMORYADDR0 		; do not have to clear the red/grn count either because the

0MEMORYADDR0 		; l.e.d's are already off.

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		lds	#StackEnd-1	; reset stack pointer

char '#'
char 'S'
stackarg 928 (@0)
char '-'
doop
doop @ 0 unary
char '1'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 927 (@0)
0MEMORYADDR0 		staa	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		staa	RTIAvrCnt

char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		cli			; enable ints (note: stop disble is 1)

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		  MAIN PACKET WAIT LOOP		     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Wait for an incomming packet 

0MEMORYADDR0 		;

0MEMORYADDR0 		; The RED led is lit when an error is detected

0MEMORYADDR0 		;

0MEMORYADDR0 		; The GRN led is lit whenever we receive a valid packet

0MEMORYADDR0 		; whos address is for us.

0MEMORYADDR0 

0MEMORYADDR0 PKT_LEN		equ	0

char '0'
stackarg 0 (@0)
0MEMORYADDR0 PKT_ADR		equ	1

char '1'
stackarg 1 (@0)
0MEMORYADDR0 PKT_CMD		equ	2

char '2'
stackarg 2 (@0)
0MEMORYADDR0 PKT_DATA	equ	3

char '3'
stackarg 3 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 

0MEMORYADDR0 WaitPacketRed	

0MEMORYADDR0 		ldaa	#56		; 3 seconds

char '#'
char '5'
stackarg 56 (@0)
0MEMORYADDR0 		staa	RTIRedCnt

char 'R'
stackarg 102 (@0)
0MEMORYADDR0 		bclr	PORTF,PORTF_RED

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; Wait for a packet.  We keep a running checksum while

0MEMORYADDR0 		; bringing in the packet and setup the loop such that

0MEMORYADDR0 		; .X will point to the CHK byte when done rather then

0MEMORYADDR0 		; one past the CHK byte.

0MEMORYADDR0 		;

0MEMORYADDR0 		;	AA

0MEMORYADDR0 		;	LEN		\

0MEMORYADDR0 		;	ADR		|

0MEMORYADDR0 		;	CMD		| LEN bytes

0MEMORYADDR0 		;	DATA[LEN-4]	|

0MEMORYADDR0 		;	CHK		/

0MEMORYADDR0 		;	55

0MEMORYADDR0 		;

0MEMORYADDR0 		; CHK does not include AA or 55.  CHK is formulated such

0MEMORYADDR0 		; that it all adds to zero.

0MEMORYADDR0 

0MEMORYADDR0 WaitPacket

0MEMORYADDR0 		bsr	GetB		; get protocol/synch

char 'G'
stackarg 0 (@0)
0MEMORYADDR0 		cmpb	#$AA		; ignore if not $AA packet

char '#'
char '$'
stackarg 170 (@0)
0MEMORYADDR0 		bne	WaitPacketRed

char 'W'
stackarg 65119 (@0)
0MEMORYADDR0 		clra			; checksum accumulation

0MEMORYADDR0 		ldx	#PacketBuf-1

char '#'
char 'P'
stackarg 107 (@0)
char '-'
doop
doop @ 0 unary
char '1'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 106 (@0)
0MEMORYADDR0 .1		bsr	GetB		; get byte (first byte is length)

char 'G'
stackarg 0 (@0)
0MEMORYADDR0 		inx

0MEMORYADDR0 		stab	0,x		; store

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		aba			; accumulate checksum

0MEMORYADDR0 		dec	PacketBuf

char 'P'
stackarg 107 (@0)
0MEMORYADDR0 		bne	.1

char '.'
stackarg 65136 (@0)
0MEMORYADDR0 		tsta

0MEMORYADDR0 		bne	WaitPacketRed

char 'W'
stackarg 65119 (@0)
0MEMORYADDR0 		bsr	GetB		; obtain endsynch and check

char 'G'
stackarg 0 (@0)
0MEMORYADDR0 		cmpb	#$55

char '#'
char '$'
stackarg 85 (@0)
0MEMORYADDR0 		bne	WaitPacketRed

char 'W'
stackarg 65119 (@0)
0MEMORYADDR0 					; check address

0MEMORYADDR0 		ldaa	PacketBuf+PKT_ADR

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 108 (@0)
0MEMORYADDR0 		bmi	.10

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		cmpa	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 		bne	WaitPacket

char 'W'
stackarg 65126 (@0)
0MEMORYADDR0 .10

redo 13: '2.10' 0045 0004
0MEMORYADDR0 		; Now have a valid packet, setup for return and

0MEMORYADDR0 		; execute command

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		ldab	PacketBuf+PKT_CMD

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 109 (@0)
0MEMORYADDR0 		ldaa	#22		; aprox set wdog 5 min (sto msb)

char '#'
char '2'
stackarg 22 (@0)
0MEMORYADDR0 		staa	RTIWDog	

char 'R'
stackarg 104 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		ldx	#CommandTable	; lookup the command

char '#'
char 'C'
stackarg 0 (@0)
0MEMORYADDR0 		andb	#$0E		; force command to be valid

char '#'
char '$'
stackarg 14 (@0)
0MEMORYADDR0 		abx

0MEMORYADDR0 		ldx	0,x		; get pointer to command

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 

0MEMORYADDR0 					; setup part of response

0MEMORYADDR0 		ldaa	#$20

char '#'
char '$'
stackarg 32 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_ADR

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 108 (@0)
0MEMORYADDR0 		ldaa	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_CMD

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 109 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		jsr	0,x		; Execute the command

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		bsr	TransmitPacket

char 'T'
stackarg 0 (@0)
0MEMORYADDR0 		bra	WaitPacket

char 'W'
stackarg 65126 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; Upon completion transmit back .B bytes of data.. that is,

0MEMORYADDR0 		; a packet:

0MEMORYADDR0 		;    AA LEN ADR+$20 FLG DATA[.B] CHK $55	(LEN=.B+4)

0MEMORYADDR0 

0MEMORYADDR0 TransmitPacket

redo 13: 'TransmitPacket' 0045 0004
0MEMORYADDR0 		ldaa	#9		; set green led 0.5 sec

char '#'
char '9'
stackarg 9 (@0)
0MEMORYADDR0 		staa	RTIGrnCnt

char 'R'
stackarg 103 (@0)
0MEMORYADDR0 		bclr	PORTF,PORTF_GRN

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 32 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		addb	#4

char '#'
char '4'
stackarg 4 (@0)
0MEMORYADDR0 		stab	PacketBuf+PKT_LEN

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 0 (@1)
evaltop @(A,O) 2 1
stackarg 107 (@0)
0MEMORYADDR0 		ldx	#PacketBuf

char '#'
char 'P'
stackarg 107 (@0)
0MEMORYADDR0 		clra			; checksum

0MEMORYADDR0 		bclr	SCCR2,SCCR2_RE	; disable receiver

char 'S'
stackarg 45 (@0)
char ','
char 'S'
stackarg 4 (@0)
0MEMORYADDR0 		ldab	#$AA		; sync

char '#'
char '$'
stackarg 170 (@0)
0MEMORYADDR0 .110		bsr	SendB		; send loop, everything except checksum

char 'S'
stackarg 0 (@0)
0MEMORYADDR0 		ldab	0,x

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		inx

0MEMORYADDR0 		sba

0MEMORYADDR0 		dec	PacketBuf+PKT_LEN

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 0 (@1)
evaltop @(A,O) 2 1
stackarg 107 (@0)
0MEMORYADDR0 		bne	.110

char '.'
stackarg 65212 (@0)
0MEMORYADDR0 		aba

0MEMORYADDR0 		tab			; send checksum

0MEMORYADDR0 		bsr	SendB

char 'S'
stackarg 0 (@0)
0MEMORYADDR0 		ldab	#$55

char '#'
char '$'
stackarg 85 (@0)
0MEMORYADDR0 		bsr	SendB

char 'S'
stackarg 0 (@0)
0MEMORYADDR0 .120		brclr	SCSR,SCSR_TC,.120

char 'S'
stackarg 46 (@0)
char ','
char 'S'
stackarg 64 (@0)
char ','
char '.'
stackarg 65231 (@0)
0MEMORYADDR0 		bset	SCCR2,SCCR2_RE	; reenable receiver

char 'S'
stackarg 45 (@0)
char ','
char 'S'
stackarg 4 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		; GETB - receive a character from the serial port

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 GetBLoop	wai

0MEMORYADDR0 GetB 		brclr	SCSR,SCSR_RDRF,GetBLoop

redo 13: 'GetB' 0045 0004
char 'S'
stackarg 46 (@0)
char ','
char 'S'
stackarg 32 (@0)
char ','
char 'G'
stackarg 65239 (@0)
0MEMORYADDR0 		ldab	SCDR

char 'S'
stackarg 47 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		; SENDB - transmit a character to the serial port

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 SendBLoop	wai

0MEMORYADDR0 SendB 		brclr	SCSR,SCSR_TDRE,SendBLoop

redo 13: 'SendB' 0045 0004
char 'S'
stackarg 46 (@0)
char ','
char 'S'
stackarg 128 (@0)
char ','
char 'S'
stackarg 65247 (@0)
0MEMORYADDR0 		stab	SCDR

char 'S'
stackarg 47 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		     	COMMANDS

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		;  A command must return the response length in .B, 0

0MEMORYADDR0 		;  if no data (returns a packet with no data)

0MEMORYADDR0 		;

0MEMORYADDR0 		;  00	IDENTIFY

0MEMORYADDR0 		;  02   READ BYTES

0MEMORYADDR0 		;  04   WRITE BYTES

0MEMORYADDR0 		;  06   PROGRAM EEPROM BYTE

0MEMORYADDR0 		;  08   RESET

0MEMORYADDR0 		;  0A   CONFIGURE

0MEMORYADDR0 		;  0C   BAD CMD

0MEMORYADDR0 		;  0E   BAD CMD

0MEMORYADDR0 

0MEMORYADDR0 CommandTable

redo 13: 'CommandTable' 0045 0004
0MEMORYADDR0 		dc.w	IdentifyCmd

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		dc.w	ReadBytesCmd

char 'R'
stackarg 0 (@0)
0MEMORYADDR0 		dc.w	WriteBytesCmd

char 'W'
stackarg 0 (@0)
0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		dc.w	BadCmd

char 'B'
stackarg 0 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 		dc.w	ProgramByteCmd

0MEMORYADDR0 	       eif

0MEMORYADDR0 		dc.w	ResetCmd

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	ConfigureCmd

char 'C'
stackarg 0 (@0)
0MEMORYADDR0 		dc.w	BadCmd

char 'B'
stackarg 0 (@0)
0MEMORYADDR0 		dc.w	BadCmd

char 'B'
stackarg 0 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;  BADCMD

0MEMORYADDR0 		;

0MEMORYADDR0 		;  Bad command, simply ignore... return an empty packet

0MEMORYADDR0 

0MEMORYADDR0 BadCmd		subroutine

redo 13: 'BadCmd' 0045 0004
0MEMORYADDR0 		clrb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;  CONFIGURECMD

0MEMORYADDR0 		;

0MEMORYADDR0 		;  Configure an I/O board, copy data to RTUConfig and PORTA

0MEMORYADDR0 

0MEMORYADDR0 ConfigureCmd	subroutine

redo 13: 'ConfigureCmd' 0045 0004
0MEMORYADDR0 		ldd	PacketBuf+PKT_DATA

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		staa	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		stab	PORTA

char 'P'
stackarg 0 (@0)
0MEMORYADDR0 		clrb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;   IDENTIFY	- identify board

0MEMORYADDR0 		;

0MEMORYADDR0 		;   returns board type, board address, board temp, board id

0MEMORYADDR0 		;

0MEMORYADDR0 		;   IdentifyUncCmd only identifies unconfigured boards

0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 IdentifyCmd

redo 13: 'IdentifyCmd' 0045 0004
0MEMORYADDR0 		ldaa	#1

char '#'
char '1'
stackarg 1 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_DATA

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		ldaa	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_DATA+1

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '1'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 111 (@0)
0MEMORYADDR0 		ldd	ADR1

char 'A'
stackarg 49 (@0)
0MEMORYADDR0 		std	PacketBuf+PKT_DATA+2

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '2'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 112 (@0)
0MEMORYADDR0 		ldab	#4

char '#'
char '4'
stackarg 4 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;   READ BYTES - read data bytes

0MEMORYADDR0 		;

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 ReadBytesCmd	subroutine

redo 13: 'ReadBytesCmd' 0045 0004
0MEMORYADDR0 		ldx	PacketBuf+PKT_DATA	; source address

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		ldy	#PacketBuf+PKT_DATA+3	; destination address

char '#'
char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '3'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 113 (@0)
0MEMORYADDR0 memCpy		clrb

0MEMORYADDR0 memCpyLoop	ldaa	0,x

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		staa	0,y

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		inx

0MEMORYADDR0 		iny

0MEMORYADDR0 		incb

0MEMORYADDR0 		cmpb	PacketBuf+PKT_DATA+2

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '2'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 112 (@0)
0MEMORYADDR0 		bne	memCpyLoop

char 'm'
stackarg 65303 (@0)
0MEMORYADDR0 		addb	#3

char '#'
char '3'
stackarg 3 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;   WRITE BYTES - write data bytes, written data returned

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 WriteBytesCmd	subroutine

redo 13: 'WriteBytesCmd' 0045 0004
0MEMORYADDR0 		ldx	#PacketBuf+PKT_DATA+3	; source address

char '#'
char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '3'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 113 (@0)
0MEMORYADDR0 		ldy	PacketBuf+PKT_DATA	; destination address

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		bra	memCpy

char 'm'
stackarg 65302 (@0)
0MEMORYADDR0 

0MEMORYADDR0 	       ifnconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		;   PROGRAM BYTE - write one byte of data to eeprom

0MEMORYADDR0 		;

0MEMORYADDR0 		;   Command:	addr cmd ADRH ADRL LEN DATA[]

0MEMORYADDR0 		;   Response:	40+X err 

0MEMORYADDR0 

0MEMORYADDR0 ProgramByteCmd	subroutine

0MEMORYADDR0 		ldx	PacketBuf+PKT_DATA	; destination address

0MEMORYADDR0 		ldab	PacketBuf+PKT_DATA+2	; # of bytes to write

0MEMORYADDR0 		ldy	#PacketBuf+PKT_DATA+3	; source address

0MEMORYADDR0 pbloop		pshb

0MEMORYADDR0 		ldab	0,y

0MEMORYADDR0 		bsr	eepromWrite

0MEMORYADDR0 		pulb

0MEMORYADDR0 		inx

0MEMORYADDR0 		iny

0MEMORYADDR0 		decb

0MEMORYADDR0 		bne	pbloop

0MEMORYADDR0 		; clrb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		; eepromWrite - write data in .B to eeprom address .X

0MEMORYADDR0 		;

0MEMORYADDR0 		; .B, .X left alone

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 eepromWrite	subroutine

0MEMORYADDR0 		ldaa	#PPROG_BYTE|PPROG_ERASE|PPROG_EELAT

0MEMORYADDR0 		bsr	.10

0MEMORYADDR0 		ldaa	#PPROG_EELAT

0MEMORYADDR0 .10		staa	PPROG

0MEMORYADDR0 		stab	0,x

0MEMORYADDR0 		bset	PPROG,PPROG_EEPGM

0MEMORYADDR0 

0MEMORYADDR0 		pshb

0MEMORYADDR0 		ldd	TCNT

0MEMORYADDR0 		addd	#12228

0MEMORYADDR0 .11		cpd	TCNT		; D-TCNT

0MEMORYADDR0 		bpl	.11

0MEMORYADDR0 		pulb

0MEMORYADDR0 

0MEMORYADDR0 		clra

0MEMORYADDR0 		staa	PPROG

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		   COUNTER INTERRUPTS

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; IC1 - digital input counter 2 

0MEMORYADDR0 		; IC2 - digital input counter 1

0MEMORYADDR0 

0MEMORYADDR0 IC1Int

0MEMORYADDR0 		ldx	Counter2

char 'C'
stackarg 100 (@0)
0MEMORYADDR0 		inx

0MEMORYADDR0 		stx	Counter2

char 'C'
stackarg 100 (@0)
0MEMORYADDR0 		bclr	TFLG1,<~TFLG1_IC1F

char 'T'
stackarg 35 (@0)
char ','
char '<'
doop
doop @ 0 unary
char '~'
doop
doop @ 1 unary
char 'T'
stackarg 4 (@0)
evaltop @(A,O) 1 2
stackarg -5 (@0)
evaltop @(A,O) 1 1
stackarg 251 (@0)
0MEMORYADDR0 		rti

0MEMORYADDR0 

0MEMORYADDR0 IC2Int

0MEMORYADDR0 		ldx	Counter1

char 'C'
stackarg 98 (@0)
0MEMORYADDR0 		inx

0MEMORYADDR0 		stx	Counter1

char 'C'
stackarg 98 (@0)
0MEMORYADDR0 		bclr	TFLG1,<~TFLG1_IC2F

char 'T'
stackarg 35 (@0)
char ','
char '<'
doop
doop @ 0 unary
char '~'
doop
doop @ 1 unary
char 'T'
stackarg 2 (@0)
evaltop @(A,O) 1 2
stackarg -3 (@0)
evaltop @(A,O) 1 1
stackarg 253 (@0)
0MEMORYADDR0 		rti

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		     GET BOARD ADDRESS		     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; GetBoardAddr - calculate board network address 00-0F

0MEMORYADDR0 		;		 and return in .B

0MEMORYADDR0 		;

0MEMORYADDR0 		;	ADR4 (msb) and ADR3 (lsb) contain the address.  

0MEMORYADDR0 		;	Each A/D is valued as shown below.  We conver the

0MEMORYADDR0 		;	A/D value to a two bit address simply by multiplying

0MEMORYADDR0 		;	it by x3 and extracting the top two bits.  The

0MEMORYADDR0 		;	result is also flexible enough to allow variations in

0MEMORYADDR0 		;	ADC values.

0MEMORYADDR0 		;

0MEMORYADDR0 		;		**xxxxxx

0MEMORYADDR0 		;

0MEMORYADDR0 		; 00 x 3 =  00  00000000

0MEMORYADDR0 		; 1E x 3 =  5A  01011010

0MEMORYADDR0 		; 37 x 3 =  A5  10100101

0MEMORYADDR0 		; 4B x 3 =  E1  11100001

0MEMORYADDR0 

0MEMORYADDR0 GetBoardAddr	subroutine

0MEMORYADDR0 		clrb			; address accumulator

0MEMORYADDR0 		ldaa	ADR4

char 'A'
stackarg 52 (@0)
0MEMORYADDR0 		bsr	oneOfFour

char 'o'
stackarg 0 (@0)
0MEMORYADDR0 		ldaa	ADR3

char 'A'
stackarg 51 (@0)
0MEMORYADDR0 oneOfFour

redo 13: 'oneOfFour' 0045 0004
0MEMORYADDR0 		pshb

0MEMORYADDR0 		tab

0MEMORYADDR0 		asla

0MEMORYADDR0 		aba

0MEMORYADDR0 		pulb

0MEMORYADDR0 

0MEMORYADDR0 		asla

0MEMORYADDR0 		rolb

0MEMORYADDR0 		asla

0MEMORYADDR0 		rolb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		     OC1 INTERRUPT

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; The OC1 interrupt is set to occur at 3840Hz (~260uS).  Each

0MEMORYADDR0 		; interrupt switches channel so each individual channel is

0MEMORYADDR0 		; effectively sampled at 240Hz.  256 samples are accumulated

0MEMORYADDR0 		; yielding a 20 bit sum which is normalized to 16 bits and

0MEMORYADDR0 		; transfered to another ram address for reading by the RTU.

0MEMORYADDR0 		;

0MEMORYADDR0 		; Working the math, you will also notice that 256 samples at

0MEMORYADDR0 		; 240 Hz winds up being an integral number of 60Hz cycles,

0MEMORYADDR0 		; therefore any 60Hz hum (and most harmonics of 60Hz) are 

0MEMORYADDR0 		; automatically removed.

0MEMORYADDR0 		;

0MEMORYADDR0 		; The OC1 interrupt also serves the following functions:

0MEMORYADDR0 		;    * Break WAI instruction in main loop for serial poll

0MEMORYADDR0 		;    * Handle LEDs and watchdog countdown

0MEMORYADDR0 		;    * Ensure processor runs long enough for ADC to convert

0MEMORYADDR0 

0MEMORYADDR0 OC1Int		subroutine

0MEMORYADDR0 

0MEMORYADDR0 		; 1.2288MHzx320 (3840Hz) Max176 scan

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 		ldab	PORTG

char 'P'
stackarg 2 (@0)
0MEMORYADDR0 		lsrb

0MEMORYADDR0 		lsrb

0MEMORYADDR0 		ldx	#MaxScanTable	; +0 primary, +32 acclsb, +64 accmsb

char '#'
char 'M'
stackarg 768 (@0)
0MEMORYADDR0 		abx

0MEMORYADDR0 		bsr	ScanMax16	; fmt ssdddddd.ddddddxx

char 'S'
stackarg 0 (@0)
0MEMORYADDR0 		andb	#$FC

char '#'
char '$'
stackarg 252 (@0)
0MEMORYADDR0 		aslb

0MEMORYADDR0 		rola

0MEMORYADDR0 		aslb

0MEMORYADDR0 		rola			

0MEMORYADDR0 		bcc	.4		; if negative, msb is all 1's

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		dec	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 .4		addd	32,x		; fmt dddddddd.dddd0000

redo 13: '11.4' 0045 0004
char '3'
stackarg 32 (@0)
char ','
0MEMORYADDR0 		bcc	.5		; carry

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		inc	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 .5		tst	RTIAvrCnt

redo 13: '11.5' 0045 0004
char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		bne	.10		; fmt 0ddddddd.dddddddd.dddd0000

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		aslb			; cvt to dddddddd.dddddddd

0MEMORYADDR0 		tab

0MEMORYADDR0 		rolb

0MEMORYADDR0 		ldaa	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 		rola

0MEMORYADDR0 		std	0,x

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		clra			; setup to clear msb, lsb

0MEMORYADDR0 		clrb

0MEMORYADDR0 		staa	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 .10		std	32,x

redo 13: '11.10' 0045 0004
char '3'
stackarg 32 (@0)
char ','
0MEMORYADDR0 		ldab	PORTG

char 'P'
stackarg 2 (@0)
0MEMORYADDR0 		addb	#$08

char '#'
char '$'
stackarg 8 (@0)
0MEMORYADDR0 		bpl	.20

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		ldaa	RTIAvrCnt

char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		adda	#$02		; $10=16 samp/avr, $02=128 samp avr

char '#'
char '$'
stackarg 2 (@0)
0MEMORYADDR0 		staa	RTIAvrCnt

char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		clrb

0MEMORYADDR0 .20		stab	PORTG

redo 13: '11.20' 0045 0004
char 'P'
stackarg 2 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; Setup for next interrupt

0MEMORYADDR0 		;

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		bclr	TFLG1,<~TFLG1_OC1F

char 'T'
stackarg 35 (@0)
char ','
char '<'
doop
doop @ 0 unary
char '~'
doop
doop @ 1 unary
char 'T'
stackarg 128 (@0)
evaltop @(A,O) 1 2
stackarg -129 (@0)
evaltop @(A,O) 1 1
stackarg 127 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		ldd	TOC1

char 'T'
stackarg 22 (@0)
0MEMORYADDR0 		addd	#320

char '#'
char '3'
stackarg 320 (@0)
0MEMORYADDR0 		std	TOC1

char 'T'
stackarg 22 (@0)
0MEMORYADDR0 		bcc	.200

char '.'
stackarg 0 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; x65536 (18.75 Hz) code

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		dec	RTIRedCnt

char 'R'
stackarg 102 (@0)
0MEMORYADDR0 		bne	.100

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		bset	PORTF,PORTF_RED

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 16 (@0)
0MEMORYADDR0 .100		

redo 13: '11.100' 0045 0004
0MEMORYADDR0 		dec	RTIGrnCnt

char 'R'
stackarg 103 (@0)
0MEMORYADDR0 		bne	.101

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		bset	PORTF,PORTF_GRN

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 32 (@0)
0MEMORYADDR0 .101		

redo 13: '11.101' 0045 0004
0MEMORYADDR0 		ldx	RTIWDog

char 'R'
stackarg 104 (@0)
0MEMORYADDR0 		dex

0MEMORYADDR0 		stx	RTIWDog

char 'R'
stackarg 104 (@0)
0MEMORYADDR0 		beq	.102r

char '.'
stackarg 0 (@0)
0MEMORYADDR0 .102

0MEMORYADDR0 		bsr	GetBoardAddr	; obtain board address

char 'G'
stackarg 65345 (@0)
0MEMORYADDR0 		cmpb	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 		beq	.103

char '.'
stackarg 0 (@0)
0MEMORYADDR0 		stab	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 .102r

redo 13: '11.102r' 0045 0004
0MEMORYADDR0 		clr	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		bclr	PORTF,PORTF_DIGOUT1|PORTF_DIGOUT2

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 64 (@0)
char '|'
doop
doop @ 0 unary
char 'P'
stackarg 128 (@1)
evaltop @(A,O) 2 1
stackarg 192 (@0)
0MEMORYADDR0 .103

redo 13: '11.103' 0045 0004
0MEMORYADDR0 

0MEMORYADDR0 		;

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 .200		

redo 13: '11.200' 0045 0004
0MEMORYADDR0 		rti

0MEMORYADDR0 

0MEMORYADDR0 		; SCANMAX16 - scan Max176

0MEMORYADDR0 		;

0MEMORYADDR0 		; This routine may not be interrupted due to sample-and-hold

0MEMORYADDR0 		; droop in the Max176.  We use the SPI to generate 16 clocks

0MEMORYADDR0 		; to the Max176 after the rising edge of strobe.  The falling

0MEMORYADDR0 		; edge of strobe must occur before the 12th bit and can occur

0MEMORYADDR0 		; as soon as the second bit.

0MEMORYADDR0 

0MEMORYADDR0 ScanMax16	subroutine

redo 13: 'ScanMax16' 0045 0004
0MEMORYADDR0 		bset	PORTG,PORTG_ADSTROBHI

char 'P'
stackarg 2 (@0)
char ','
char 'P'
stackarg 4 (@0)
0MEMORYADDR0 		bsr	Get8B			; 13 from store

char 'G'
stackarg 0 (@0)
0MEMORYADDR0 		bsr	Get8A			; 16 to load, 13 from store

char 'G'
stackarg 0 (@0)
0MEMORYADDR0 Get8A		bclr	PORTG,PORTG_ADSTROBHI	; 6

redo 13: 'Get8A' 0045 0004
char 'P'
stackarg 2 (@0)
char ','
char 'P'
stackarg 4 (@0)
0MEMORYADDR0 		tba				; 2

0MEMORYADDR0 Get8B		tst	SPSR			; 3

redo 13: 'Get8B' 0045 0004
char 'S'
stackarg 41 (@0)
0MEMORYADDR0 		ldab	SPDR			; 3

char 'S'
stackarg 42 (@0)
0MEMORYADDR0 		stab	SPDR			; 3

char 'S'
stackarg 42 (@0)
0MEMORYADDR0 		asla				; 2

0MEMORYADDR0 		asla				; 2

0MEMORYADDR0 		asra				; 2

0MEMORYADDR0 		asra				; 2

0MEMORYADDR0 		rts				; 5

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		    INTERRUPT VECTORS	     	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Interrupt Vectors

0MEMORYADDR0 		;

0MEMORYADDR0 		; note: if we need the space we can use some of this space

0MEMORYADDR0 		; for code (for those interrupt vectors we do not use)

0MEMORYADDR0 

0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		org	$FFD6+9*2

char '$'
stackarg 65494 (@0)
char '+'
doop
doop @ 0 unary
char '9'
stackarg 9 (@1)
char '*'
doop
doop @ 1
char '2'
stackarg 2 (@2)
evaltop @(A,O) 3 2
stackarg 18 (@1)
evaltop @(A,O) 2 1
stackarg 65512 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;;dc.w	BadInt		; SCI serial

0MEMORYADDR0 		;;dc.w	BadInt		; SPIE

0MEMORYADDR0 		;;dc.w	BadInt		; PAII Pulse Accumulator

0MEMORYADDR0 		;;dc.w	BadInt		; PAOVI Pulse Accumulator Overflow

0MEMORYADDR0 		;;dc.w	BadInt		; TOI Timer overflow

0MEMORYADDR0 		;;dc.w	BadInt		; OC5

0MEMORYADDR0 		;;dc.w	BadInt		; OC4

0MEMORYADDR0 		;;dc.w	BadInt		; OC3

0MEMORYADDR0 		;;dc.w	BadInt		; OC2

0MEMORYADDR0 		dc.w	OC1Int		; OC1

char 'O'
stackarg 65362 (@0)
0MEMORYADDR0 		dc.w	BadInt		; IC3

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	IC2Int		; IC2

char 'I'
stackarg 65336 (@0)
0MEMORYADDR0 		dc.w	IC1Int		; IC1

char 'I'
stackarg 65327 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		dc.w	BadInt		; RTI Realtime interrupt

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	BadInt		; IRQ

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	BadInt		; XIRQ

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	BadInt		; SWI

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; Illegal OpCode Trap

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; COP failure (reset)

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; Clock Monitor Failure

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; RESET

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 		;   FATROM.ASM

0MEMORYADDR0 		;

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			MEMORY MAP	 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		;   We throw away some internal ram (96 bytes) in order

0MEMORYADDR0 		;   to use direct addressing for the majority of memory

0MEMORYADDR0 		;   accesses by mapping the registers at 0.

0MEMORYADDR0 		;

0MEMORYADDR0 		;   MC68HC11F1 port and bit assignments

0MEMORYADDR0 		;

0MEMORYADDR0 		;   We setup a very fast OC1 interrupt.. around 208uS, to

0MEMORYADDR0 		;   handle main system timing.  This also allows us to have

0MEMORYADDR0 		;   a WAI instruction in our serial poll loop to lower power

0MEMORYADDR0 		;   consumption.

0MEMORYADDR0 

0MEMORYADDR0 RAM		equ	$0000		;   1K byte of RAM

char '$'
stackarg 0 (@0)
0MEMORYADDR0 LORAMBEG	equ	$0060		;   96 unusable due to ctl regs

char '$'
stackarg 96 (@0)
0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 HIRAMBEG	equ	$0300		;   hardwired for RTU software

char '$'
stackarg 768 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 HIRAMBEG	equ	$0320

0MEMORYADDR0 	       eif

0MEMORYADDR0 REGS		equ	$0000		;   96 control regs (after INIT)

char '$'
stackarg 0 (@0)
0MEMORYADDR0 EEPROM		equ	$FE00		;   512 bytes EEPROM

char '$'
stackarg 65024 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTA		equ	REGS+$00	;   i/o port A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 0 (@1)
evaltop @(A,O) 2 1
stackarg 0 (@0)
0MEMORYADDR0 PORTA_24V	equ	$80		;   24V power switch

char '$'
stackarg 128 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRA		equ	REGS+$01	;

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTG		equ	REGS+$02

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 2 (@0)
0MEMORYADDR0 CSPROG		equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 CSGEN		equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 CS101		equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 CS102		equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PORTG_RESERVED7 equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PORTG_MUXSEL3	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PORTG_MUXSEL2	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 PORTG_MUXSEL1	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PORTG_MUXSEL0	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 PORTG_ADSTROBHI equ	$04

char '$'
stackarg 4 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRG		equ	REGS+$03

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 3 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTB		equ	REGS+$04	;   i/o port B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 4 (@1)
evaltop @(A,O) 2 1
stackarg 4 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTF		equ     REGS+$05	;   PORTF l.e.d's and digout 1 & 2

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 5 (@1)
evaltop @(A,O) 2 1
stackarg 5 (@0)
0MEMORYADDR0 PORTF_DIGOUT2	equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PORTF_DIGOUT1	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PORTF_GRN	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 PORTF_RED	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTC		equ	REGS+$06

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 6 (@1)
evaltop @(A,O) 2 1
stackarg 6 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRC		equ	REGS+$07

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 7 (@1)
evaltop @(A,O) 2 1
stackarg 7 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTD		equ	REGS+$08

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 8 (@1)
evaltop @(A,O) 2 1
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 DDRD		equ	REGS+$09

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 9 (@1)
evaltop @(A,O) 2 1
stackarg 9 (@0)
0MEMORYADDR0 

0MEMORYADDR0 PORTE		equ	REGS+$0A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 10 (@1)
evaltop @(A,O) 2 1
stackarg 10 (@0)
0MEMORYADDR0 

0MEMORYADDR0 CFORC		equ	REGS+$0B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 11 (@1)
evaltop @(A,O) 2 1
stackarg 11 (@0)
0MEMORYADDR0 CFORC_FOC1	equ	$80	; FORCE OUTPUT COMPARE 1-4

char '$'
stackarg 128 (@0)
0MEMORYADDR0 CFORC_FOC2	equ	$40	;	....OR'D WITH TOC'S

char '$'
stackarg 64 (@0)
0MEMORYADDR0 CFORC_FOC3	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 CFORC_FOC4	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 CFORC_FOC5	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OC1M		equ	REGS+$0C	; OUTPUT COMPARE MASK

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 12 (@1)
evaltop @(A,O) 2 1
stackarg 12 (@0)
0MEMORYADDR0 OC1_M7		equ	$80	; ALLOWS COUNTER COMPARE OUTPUTS ESTABLISHED BY

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OC1_M6		equ	$40	; OC1D6-D3 ON PA

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OC1_M5		equ	$20	;   EXCEPT FOR OC1M7 WHICH ALLOWS EITHER

char '$'
stackarg 32 (@0)
0MEMORYADDR0 OC1_M4		equ	$10	; INTERNAL DATA (0) OR OC1D7 DURING WRITES TO

char '$'
stackarg 16 (@0)
0MEMORYADDR0 OC1_M3		equ	$08	; PA7

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OC1D		equ	REGS+$0D

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 13 (@1)
evaltop @(A,O) 2 1
stackarg 13 (@0)
0MEMORYADDR0 OC1_d7		equ	$80	; STATES WHICH WILL BE PRESENT ON PA6-PA3

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OC1_d6		equ	$40	; WHEN PERMITTED BY OC1_M6-M3

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OC1_d5		equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 OC1_d4		equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 OC1_d3		equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TCNT		equ	REGS+$0E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 14 (@1)
evaltop @(A,O) 2 1
stackarg 14 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TIC1		equ	REGS+$10

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 16 (@1)
evaltop @(A,O) 2 1
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TIC2		equ	REGS+$12

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 18 (@1)
evaltop @(A,O) 2 1
stackarg 18 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TIC3		equ	REGS+$14

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 20 (@1)
evaltop @(A,O) 2 1
stackarg 20 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC1		equ	REGS+$16

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 22 (@1)
evaltop @(A,O) 2 1
stackarg 22 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC2		equ	REGS+$18

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 24 (@1)
evaltop @(A,O) 2 1
stackarg 24 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC3		equ	REGS+$1A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 26 (@1)
evaltop @(A,O) 2 1
stackarg 26 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC4		equ	REGS+$1C

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 28 (@1)
evaltop @(A,O) 2 1
stackarg 28 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TOC5		equ	REGS+$1E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 30 (@1)
evaltop @(A,O) 2 1
stackarg 30 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TCTL1		equ	REGS+$20	;ACTION TAKEN CODES  M	L

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 32 (@1)
evaltop @(A,O) 2 1
stackarg 32 (@0)
0MEMORYADDR0 TCTL1_OM2	equ	$80	;		     0	0 -DISABLE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TCTL1_OL2	equ	$40	;		     0	1 -TOGGLE

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TCTL1_OM3	equ	$20	;		     1	0 -CLEAR

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TCTL1_OL3	equ	$10	;		     1	1 -SET

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TCTL1_OM4	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TCTL1_OL4	equ	$04	;  OR, WHAT 1 OF 4 THINGS HAPPEN TO OUT.CMP

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TCTL1_OM5	equ	$02	;  FLAGS IN TFLG1 2-5 (OCF'S 2-5)

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TCTL1_OL5	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TCTL2		equ	REGS+$21	; B  A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 33 (@1)
evaltop @(A,O) 2 1
stackarg 33 (@0)
0MEMORYADDR0 TCTL2_EDG1B	equ	$20	; 0  0 CAPTURE DISABLED

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TCTL2_EDG1A	equ	$10	; 0  1	 ''    ON RISING

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TCTL2_EDG2B	equ	$08	; 1  0   ''      ON FALLING

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TCTL2_EDG2A	equ	$04	; 1  1   ''    ON ANY

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TCTL2_EDG3B	equ	$02

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TCTL2_EDG3A	equ	$01

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TMSK1		equ	REGS+$22

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 34 (@1)
evaltop @(A,O) 2 1
stackarg 34 (@0)
0MEMORYADDR0 TMSK1_OC1I	equ	$80	;

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TMSK1_OC2I	equ	$40	; ENABLE OUTPUT COMPARE INTERRUPT WHEN SET

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TMSK1_OC3I	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TMSK1_OC4I	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TMSK1_OC5I	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TMSK1_IC1I	equ	$04	; ENABLE INTERUPTS ON CAPTURE FLAG WHEN SET

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TMSK1_IC2I	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TMSK1_IC3I	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TFLG1		equ	REGS+$23

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 35 (@1)
evaltop @(A,O) 2 1
stackarg 35 (@0)
0MEMORYADDR0 TFLG1_OC1F	equ	$80	; CORRESPONDING FLAGS TO THE ABOVE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TFLG1_OC2F	equ	$40	;

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TFLG1_OC3F	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TFLG1_OC4F	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TFLG1_OC5F	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TFLG1_IC1F	equ	$04	;

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TFLG1_IC2F	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TFLG1_IC3F	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;NOTE: PR1 & PR0 MUST BE WRITTEN IMMEDIATELY AFTER RESET!!

0MEMORYADDR0 

0MEMORYADDR0 TMSK2		equ	REGS+$24

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 36 (@1)
evaltop @(A,O) 2 1
stackarg 36 (@0)
0MEMORYADDR0 TMSK2_TOI	equ	$80	; Timer overflow interrupt enable

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TMSK2_RTII	equ	$40	; Real time interrupt

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TMSK2_PAOVI	equ	$20	; Pulse accumulator overflow

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TMSK2_PAII	equ	$10	; Pulse accumulator count

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TMSK2_PR1	equ	$02	; Timer prescale select

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TMSK2_PR0	equ	$01	;  0,0=/1  0,1=/4  1,0=/8  1,1=/16

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 TFLG2		equ	REGS+$25

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 37 (@1)
evaltop @(A,O) 2 1
stackarg 37 (@0)
0MEMORYADDR0 TFLG2_TOF	equ	$80	; FLAGS FOR THE ABOVE 1ST 4 INTERRUPTS

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TFLG2_RTIF	equ	$40	;

char '$'
stackarg 64 (@0)
0MEMORYADDR0 TFLG2_PAOVF	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TFLG2_PAIF	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 PACTL		equ	REGS+$26

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 38 (@1)
evaltop @(A,O) 2 1
stackarg 38 (@0)
0MEMORYADDR0 PACTL_DDRA7	equ	$80	; 0=INPUT ONLY, 1=OUTPUT

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PACTL_PAEN	equ	$40	; ENABLE PA

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PACTL_PAMOD	equ	$20	; 0=COUNT EXTERNAL EVENTS,1=GATED TIME ACCUM.

char '$'
stackarg 32 (@0)
0MEMORYADDR0 PACTL_PEDGE	equ	$10	; 0=INC ON FALLING OR INHIBITS CNT;1=OPPOSITE

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PACTL_RTR1	equ	$02 	; Divider for real time interrupt

char '$'
stackarg 2 (@0)
0MEMORYADDR0 PACTL_RTR0	equ	$01 	; Divide by 2^13, 2^14, 2^15, or 2^16

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 PACNT		equ	REGS+$27

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 39 (@1)
evaltop @(A,O) 2 1
stackarg 39 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SPCR		equ	REGS+$28

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 40 (@1)
evaltop @(A,O) 2 1
stackarg 40 (@0)
0MEMORYADDR0 SPCR_SPIE	equ	$80	; serial PERIPH INTERRUPT ENABLE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SPCR_SPE	equ	$40	; serial periph system enable

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SPCR_DWOM	equ	$20	; PORT D WIRED-OR 0=TOTEM,1=OPEN DRAIN

char '$'
stackarg 32 (@0)
0MEMORYADDR0 SPCR_MSTR	equ	$10	; 0=SLAVE, 1=MASTER

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SPCR_CPOL	equ	$08	; 0=ACT. HIGH CLKS;SCK IDLES LOW--1 IS OPPOSITE

char '$'
stackarg 8 (@0)
0MEMORYADDR0 SPCR_CPHA	equ	$04	; CLOCK PHASE

char '$'
stackarg 4 (@0)
0MEMORYADDR0 SPCR_SPR1	equ	$02	;	  E CLOCK /  2	 4   16   32

char '$'
stackarg 2 (@0)
0MEMORYADDR0 SPCR_SPR0	equ	$01	;		     00  01  10   11

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SPSR		equ	REGS+$29

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 41 (@1)
evaltop @(A,O) 2 1
stackarg 41 (@0)
0MEMORYADDR0 SPSR_SPIF	equ	$80	; TXFR COMPLETE

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SPSR_WCOL	equ	$40	; WRITE COLLISION

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SPSR_MODF	equ	$10	; MODE-FAULT ERROR FLAG

char '$'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SPDR		equ	REGS+$2A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 42 (@1)
evaltop @(A,O) 2 1
stackarg 42 (@0)
0MEMORYADDR0 

0MEMORYADDR0 BAUD		equ	REGS+$2B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 43 (@1)
evaltop @(A,O) 2 1
stackarg 43 (@0)
0MEMORYADDR0 BAUD_TCLR	equ	$80 	; 0

char '$'
stackarg 128 (@0)
0MEMORYADDR0 BAUD_SCP1	equ	$20 	; divide e by 1  3  4   13

char '$'
stackarg 32 (@0)
0MEMORYADDR0 BAUD_SCP0	equ	$10 	;	      00 01 10  11

char '$'
stackarg 16 (@0)
0MEMORYADDR0 BAUD_RCKB	equ	$08 	; 0

char '$'
stackarg 8 (@0)
0MEMORYADDR0 BAUD_SCR2	equ	$04 	; divide prescaler out by 1,  2   4,.....128

char '$'
stackarg 4 (@0)
0MEMORYADDR0 BAUD_SCR1	equ	$02 	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 BAUD_SCR0	equ	$01 	; scr0,1,2 =    000 001 010.....111

char '$'
stackarg 1 (@0)
0MEMORYADDR0 BAUD_4800	equ	BAUD_SCP1|BAUD_SCR1

char 'B'
stackarg 32 (@0)
char '|'
doop
doop @ 0 unary
char 'B'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 34 (@0)
0MEMORYADDR0 BAUD_9600	equ	BAUD_SCR0|BAUD_SCR1

char 'B'
stackarg 1 (@0)
char '|'
doop
doop @ 0 unary
char 'B'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 3 (@0)
0MEMORYADDR0 BAUD_19200	equ	BAUD_SCR1

char 'B'
stackarg 2 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 SCCR1		equ	REGS+$2C

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 44 (@1)
evaltop @(A,O) 2 1
stackarg 44 (@0)
0MEMORYADDR0 SCCR1_R8	equ	$80 	; get the ninth bit here, if 'M' bit is set

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SCCR1_T8	equ	$40	; set this bit for the 9th tx bit if 'M' is set

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SCCR1_M 	equ	$10	; 'M'

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SCCR1_WAKE	equ	$08	; 0=idle line, 1=address mark

char '$'
stackarg 8 (@0)
0MEMORYADDR0 

0MEMORYADDR0 SCCR2		equ	REGS+$2D

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 45 (@1)
evaltop @(A,O) 2 1
stackarg 45 (@0)
0MEMORYADDR0 SCCR2_TIE	equ	$80	; Transmit interrupt enable

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SCCR2_TCIE	equ	$40	; Transmit Complete interr en

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SCCR2_RIE	equ	$20	; Receiver Interrupt enable

char '$'
stackarg 32 (@0)
0MEMORYADDR0 SCCR2_ILIE	equ	$10	; Idle Line ''       ''

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SCCR2_TE	equ	$08	; tx enable

char '$'
stackarg 8 (@0)
0MEMORYADDR0 SCCR2_RE	equ	$04	; rx """

char '$'
stackarg 4 (@0)
0MEMORYADDR0 SCCR2_RWU	equ	$02	; wake up when set

char '$'
stackarg 2 (@0)
0MEMORYADDR0 SCCR2_SBK	equ	$01	; send break

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 SCSR		equ	REGS+$2E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 46 (@1)
evaltop @(A,O) 2 1
stackarg 46 (@0)
0MEMORYADDR0 SCSR_TDRE	equ	$80	; Transmit Data Register Empty

char '$'
stackarg 128 (@0)
0MEMORYADDR0 SCSR_TC 	equ	$40	; Transmit Complete

char '$'
stackarg 64 (@0)
0MEMORYADDR0 SCSR_RDRF	equ	$20	; Receiver Data Ready

char '$'
stackarg 32 (@0)
0MEMORYADDR0 SCSR_IDLE	equ	$10	; Idle Line Detect

char '$'
stackarg 16 (@0)
0MEMORYADDR0 SCSR_OR 	equ	$08	; overrun error

char '$'
stackarg 8 (@0)
0MEMORYADDR0 SCSR_NF 	equ	$04	; noise flag

char '$'
stackarg 4 (@0)
0MEMORYADDR0 SCSR_FE 	equ	$02	; framing error

char '$'
stackarg 2 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 SCDR		equ	REGS+$2F	; sc data reg

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 47 (@1)
evaltop @(A,O) 2 1
stackarg 47 (@0)
0MEMORYADDR0 

0MEMORYADDR0 ADCTL		equ	REGS+$30

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 48 (@1)
evaltop @(A,O) 2 1
stackarg 48 (@0)
0MEMORYADDR0 ADCTL_CCF	equ	$80 	; Conversion complete, cleared on ADCTL write

char '$'
stackarg 128 (@0)
0MEMORYADDR0 ADCTL_SCAN	equ	$20	; Continuous scan mode, else single scan

char '$'
stackarg 32 (@0)
0MEMORYADDR0 ADCTL_MULT	equ	$10	; Scan all four channels or just one channel

char '$'
stackarg 16 (@0)
0MEMORYADDR0 ADCTL_CD	equ	$08	;

char '$'
stackarg 8 (@0)
0MEMORYADDR0 ADCTL_CC	equ	$04	;

char '$'
stackarg 4 (@0)
0MEMORYADDR0 ADCTL_CB	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 ADCTL_CA	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 ADR1		equ	REGS+$31	; ADC register 1

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 49 (@1)
evaltop @(A,O) 2 1
stackarg 49 (@0)
0MEMORYADDR0 ADR2		equ	REGS+$32

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 50 (@1)
evaltop @(A,O) 2 1
stackarg 50 (@0)
0MEMORYADDR0 ADR3		equ	REGS+$33

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 51 (@1)
evaltop @(A,O) 2 1
stackarg 51 (@0)
0MEMORYADDR0 ADR4		equ	REGS+$34

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 52 (@1)
evaltop @(A,O) 2 1
stackarg 52 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 BPROT		equ	REGS+$35

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 53 (@1)
evaltop @(A,O) 2 1
stackarg 53 (@0)
0MEMORYADDR0 BPROT_PTCON	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 BPROT_BPRT3	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 BPROT_BPRT2	equ	$04

char '$'
stackarg 4 (@0)
0MEMORYADDR0 BPROT_BPRT1	equ	$02

char '$'
stackarg 2 (@0)
0MEMORYADDR0 BPROT_BPRT0	equ	$01

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OPT2		equ	REGS+$38	; config options 2 register

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 56 (@1)
evaltop @(A,O) 2 1
stackarg 56 (@0)
0MEMORYADDR0 OPT2_GWOM	equ	$80

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OPT2_CWOM	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OPT2_CLK4X	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 

0MEMORYADDR0 OPTION		equ	REGS+$39

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 57 (@1)
evaltop @(A,O) 2 1
stackarg 57 (@0)
0MEMORYADDR0 OPTION_ADPU	equ	$80	; A/D power

char '$'
stackarg 128 (@0)
0MEMORYADDR0 OPTION_CSEL	equ	$40

char '$'
stackarg 64 (@0)
0MEMORYADDR0 OPTION_IRQE	equ	$20	; IRQ edge sensitive enable, else level sens.

char '$'
stackarg 32 (@0)
0MEMORYADDR0 OPTION_DLY	equ	$10	; delay 4000 E clks after stop, else 4

char '$'
stackarg 16 (@0)
0MEMORYADDR0 OPTION_CME	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 OPTION_CR1	equ	$02	; cop timer rates of E/2^15/(1,4,16,64)

char '$'
stackarg 2 (@0)
0MEMORYADDR0 OPTION_CR0	equ	$01	; for 00,01,10,11

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 COPRST		equ	REGS+$3A

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 58 (@1)
evaltop @(A,O) 2 1
stackarg 58 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; EEPROM programming register.

0MEMORYADDR0 		;

0MEMORYADDR0 		; BYTE ROW	(only valid when erase bit is set)

0MEMORYADDR0 		;  0    0	bulk erase

0MEMORYADDR0 		;  0	1	row erase

0MEMORYADDR0 		;  1	0	byte erase

0MEMORYADDR0 		;  1	1	byte erase

0MEMORYADDR0 		;

0MEMORYADDR0 		; erase sequence is:

0MEMORYADDR0 		;	+BYTE+ERASE+EELAT, write eeprom, +PGM, delay 10 ms,

0MEMORYADDR0 		;	-PGM-ERASE-EELAT

0MEMORYADDR0 		; program sequence is:  

0MEMORYADDR0 		;	+EELAT, write eeprom, +PGM, delay 10 ms, -PGM-EELAT

0MEMORYADDR0 		;

0MEMORYADDR0 		; you do not need to program to zero before erasing to 1's.

0MEMORYADDR0 

0MEMORYADDR0 PPROG		equ	REGS+$3B

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 59 (@1)
evaltop @(A,O) 2 1
stackarg 59 (@0)
0MEMORYADDR0 PPROG_ODD	equ	$80	; Factory reserved

char '$'
stackarg 128 (@0)
0MEMORYADDR0 PPROG_EVEN	equ	$40	; Factory reserved

char '$'
stackarg 64 (@0)
0MEMORYADDR0 PPROG_BYTE	equ	$10	; Byte erase mode

char '$'
stackarg 16 (@0)
0MEMORYADDR0 PPROG_ROW	equ	$08	; Row erase mode

char '$'
stackarg 8 (@0)
0MEMORYADDR0 PPROG_ERASE	equ	$04	; Erase enable

char '$'
stackarg 4 (@0)
0MEMORYADDR0 PPROG_EELAT	equ	$02	; arm eeprom write (then write to eeprom)

char '$'
stackarg 2 (@0)
0MEMORYADDR0 PPROG_EEPGM	equ	$01	; apply programming voltage

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 HPRIO		equ	REGS+$3C

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 60 (@1)
evaltop @(A,O) 2 1
stackarg 60 (@0)
0MEMORYADDR0 HPRIO_RBOOT	equ	$80	; Set in special test mode

char '$'
stackarg 128 (@0)
0MEMORYADDR0 HPRIO_SMOD	equ	$40	; ~MODB pin latched at reset

char '$'
stackarg 64 (@0)
0MEMORYADDR0 HPRIO_MDA	equ	$20	; MODB pin latched at reset, can be clrd in

char '$'
stackarg 32 (@0)
0MEMORYADDR0 				; special tes/tbootstrap mode ?

0MEMORYADDR0 HPRIO_IRV	equ	$10	; internal read visibility

char '$'
stackarg 16 (@0)
0MEMORYADDR0 HPRIO_PSEL3	equ	$08	; Select highest priority interrupt, only

char '$'
stackarg 8 (@0)
0MEMORYADDR0 HPRIO_PSEL2	equ	$04	; writable when interrupts are masked.

char '$'
stackarg 4 (@0)
0MEMORYADDR0 HPRIO_PSEL1	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 HPRIO_PSEL0	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 INIT		equ	REGS+$3D

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 61 (@1)
evaltop @(A,O) 2 1
stackarg 61 (@0)
0MEMORYADDR0 INIT_RAM3	equ	$80	; Internal ram base address in 4K chunks,

char '$'
stackarg 128 (@0)
0MEMORYADDR0 INIT_RAM2	equ	$40	; default $0000 (0000)

char '$'
stackarg 64 (@0)
0MEMORYADDR0 INIT_RAM1	equ	$20	;

char '$'
stackarg 32 (@0)
0MEMORYADDR0 INIT_RAM0	equ	$10	;

char '$'
stackarg 16 (@0)
0MEMORYADDR0 INIT_REG3	equ	$08	; Control register base address in 4K chunks,

char '$'
stackarg 8 (@0)
0MEMORYADDR0 INIT_REG2	equ	$04	; default $1000 (0001)

char '$'
stackarg 4 (@0)
0MEMORYADDR0 INIT_REG1	equ	$02	;

char '$'
stackarg 2 (@0)
0MEMORYADDR0 INIT_REG0	equ	$01	;

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 TEST1		equ	REGS+$3E

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 62 (@1)
evaltop @(A,O) 2 1
stackarg 62 (@0)
0MEMORYADDR0 TEST1_TILOP	equ	$80	; FACTORY TEST STUFF ONLY WHEN SMOD=1

char '$'
stackarg 128 (@0)
0MEMORYADDR0 TEST1_OCCR	equ	$20

char '$'
stackarg 32 (@0)
0MEMORYADDR0 TEST1_CBYP	equ	$10

char '$'
stackarg 16 (@0)
0MEMORYADDR0 TEST1_DISR	equ	$08

char '$'
stackarg 8 (@0)
0MEMORYADDR0 TEST1_FCM	equ	$04

char '$'
stackarg 4 (@0)
0MEMORYADDR0 TEST1_FCOP	equ	$02

char '$'
stackarg 2 (@0)
0MEMORYADDR0 TEST1_TCON	equ	$01

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 CONFIG		equ	REGS+$3F

char 'R'
stackarg 0 (@0)
char '+'
doop
doop @ 0 unary
char '$'
stackarg 63 (@1)
evaltop @(A,O) 2 1
stackarg 63 (@0)
0MEMORYADDR0 CONFIG_NOSEC	equ	$08	; no eeprom security

char '$'
stackarg 8 (@0)
0MEMORYADDR0 CONFIG_NOCOP	equ	$04	; no hardware watchdog

char '$'
stackarg 4 (@0)
0MEMORYADDR0 CONFIG_ROMON	equ	$02	; enable rom

char '$'
stackarg 2 (@0)
0MEMORYADDR0 CONFIG_EEON	equ	$01	; enable eeprom

char '$'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; In bootstrap mode vectors go through ram

0MEMORYADDR0 		; 

0MEMORYADDR0 

0MEMORYADDR0 BsSCIJmp	equ	$C4

char '$'
stackarg 196 (@0)
0MEMORYADDR0 BsSPIJmp	equ	$C7

char '$'
stackarg 199 (@0)
0MEMORYADDR0 BsPAIJmp	equ	$CA

char '$'
stackarg 202 (@0)
0MEMORYADDR0 BsPAOVJmp	equ	$CD

char '$'
stackarg 205 (@0)
0MEMORYADDR0 BsTOVJmp	equ	$D0

char '$'
stackarg 208 (@0)
0MEMORYADDR0 BsOC5Jmp	equ	$D3

char '$'
stackarg 211 (@0)
0MEMORYADDR0 BsOC4Jmp	equ	$D6

char '$'
stackarg 214 (@0)
0MEMORYADDR0 BsOC3Jmp	equ	$D9

char '$'
stackarg 217 (@0)
0MEMORYADDR0 BsOC2Jmp	equ	$DC

char '$'
stackarg 220 (@0)
0MEMORYADDR0 BsOC1Jmp	equ	$DF

char '$'
stackarg 223 (@0)
0MEMORYADDR0 BsIC3Jmp	equ	$E2

char '$'
stackarg 226 (@0)
0MEMORYADDR0 BsIC2Jmp	equ	$E5

char '$'
stackarg 229 (@0)
0MEMORYADDR0 BsIC1Jmp	equ	$E8

char '$'
stackarg 232 (@0)
0MEMORYADDR0 BOOTSTRAPORG	equ	$EB	; bootstrap origin

char '$'
stackarg 235 (@0)
0MEMORYADDR0 BsRTIJmp	equ	$EB

char '$'
stackarg 235 (@0)
0MEMORYADDR0 BsIRQJmp	equ	$EE

char '$'
stackarg 238 (@0)
0MEMORYADDR0 BsXIRQJmp	equ	$F1

char '$'
stackarg 241 (@0)
0MEMORYADDR0 BsSWIJmp	equ	$F4

char '$'
stackarg 244 (@0)
0MEMORYADDR0 BsILLJmp	equ	$F7

char '$'
stackarg 247 (@0)
0MEMORYADDR0 BsCOPJmp	equ	$FA

char '$'
stackarg 250 (@0)
0MEMORYADDR0 BsCMJmp		equ	$FD

char '$'
stackarg 253 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		processor 68hc11

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			RAM VARS 	 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; most/all ram variables can be accessed with direct

0MEMORYADDR0 		; addressing for the EEPROM version.

0MEMORYADDR0 

0MEMORYADDR0 		seg.u	bss

0MEMORYADDR0 		org	LORAMBEG

char 'L'
stackarg 96 (@0)
0MEMORYADDR0 

0MEMORYADDR0 RTUConfig	ds.b	1	; RTU Flags reg, cleared on reset

char '1'
stackarg 1 (@0)
0MEMORYADDR0 BoardAddr	ds.b	1	; 1 byte board address

char '1'
stackarg 1 (@0)
0MEMORYADDR0 Counter1	ds.w	1	; 2 bytes counter input

char '1'
stackarg 1 (@0)
0MEMORYADDR0 Counter2	ds.w	1	; 2 bytes counter input

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIRedCnt	ds.b	1	; real time interrupt red l.e.d. countdown

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIGrnCnt	ds.b	1	; real time interrupt grn l.e.d. countdown

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIWDog		ds.w	1	; 2 byte wdog ctr, reset by packet reception

char '1'
stackarg 1 (@0)
0MEMORYADDR0 RTIAvrCnt	ds.b	1	; 1 16 sample countdown

char '1'
stackarg 1 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; note: packet size for ram-dl version must be smaller so

0MEMORYADDR0 		; program fits in ram

0MEMORYADDR0 

0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 PacketBuf	ds.b	256+8	; maximum packet size plus slop

char '2'
stackarg 256 (@0)
char '+'
doop
doop @ 0 unary
char '8'
stackarg 8 (@1)
evaltop @(A,O) 2 1
stackarg 264 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 PacketBuf	ds.b	32+8	; maximum packet size plus slop in bootstrap

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 		; note: MaxScanTable location hardwired by ioscan for normal

0MEMORYADDR0 		; operation

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		org	HIRAMBEG

char 'H'
stackarg 768 (@0)
0MEMORYADDR0 

0MEMORYADDR0 MaxScanTable	ds.b	96	; 16 channels x 3 (holdingregx1, accumulatorx2)

char '9'
stackarg 96 (@0)
0MEMORYADDR0 Stack		ds.b	64	; Reserve 64 bytes for the stack

char '6'
stackarg 64 (@0)
0MEMORYADDR0 StackEnd	ds.b	0

char '0'
stackarg 0 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			CODE SEGMENT		     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; For EEPROM version code starts at $FE00.  For RAM bootstrap

0MEMORYADDR0 		; version code starts at zero from which we immediately jump

0MEMORYADDR0 		; forward past all registers and ram variables

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		seg	code

0MEMORYADDR0 

0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		org	$FE00

char '$'
stackarg 65024 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 		org	$0000

0MEMORYADDR0 		jmp	Reset

0MEMORYADDR0 		org	BOOTSTRAPORG

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			ROM VARS 	 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Calibration constants are at the beginning of the rom,

0MEMORYADDR0 		; consisting of two 16 bit base constants for analog channel

0MEMORYADDR0 		; 1 and two 8 bit constants for each of analog channels

0MEMORYADDR0 		; 2 through 7, two 8 bit constants for the two temp.

0MEMORYADDR0 		; sensors, two 8 bit constants for the board temp. sensor.

0MEMORYADDR0 		;

0MEMORYADDR0 		; The RTU will interpret these constants

0MEMORYADDR0 

0MEMORYADDR0 		dc.w	$FFFF,$FFFF	; Mux channel 0, 4 and 20mA	AI01

char '$'
stackarg 65535 (@0)
char ','
char '$'
stackarg 65535 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 1 (delta)		AI02

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 2 (delta)		AI03

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 3 (delta)		AI04

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 4 (delta) (unused)

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 5 (delta)		AI05

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 6 (delta)		AI06

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; Mux channel 7 (delta)		AI07

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; External temp. sensor 1

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; External temp. sensor 2

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		dc.b	$FF,$FF		; On-Board temp. sensor

char '$'
stackarg 255 (@0)
char ','
char '$'
stackarg 255 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;			RESET 		 	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Platform reset.  Interrupts are disabled and the stack

0MEMORYADDR0 		; pointer is/becomes invalid.

0MEMORYADDR0 

0MEMORYADDR0 Reset		subroutine

0MEMORYADDR0 ResetCmd

0MEMORYADDR0 BadInt

0MEMORYADDR0 		; disable interrupts, setup protected control registers

0MEMORYADDR0 		;	INIT - relocate ram and hardware regs to 0

0MEMORYADDR0 		;	OPT2 - disable clk4x output (save power)

0MEMORYADDR0 		;	OPTION - enable ADC

0MEMORYADDR0 		;

0MEMORYADDR0 		; note: due to ram/regs overlap, first 96 bytes of ram

0MEMORYADDR0 		; is unaccessable.  For bootstrapped programs, the 

0MEMORYADDR0 		; jmp to Reset becomes unaccessable after it is executed.

0MEMORYADDR0 

0MEMORYADDR0 		sei

0MEMORYADDR0 		clra			; .A = 0

0MEMORYADDR0 		staa	INIT-REGS+$1000	; map ram & regs to base address 0

char 'I'
stackarg 61 (@0)
char '-'
doop
doop @ 0 unary
char 'R'
stackarg 0 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 61 (@0)
doop @ 0
char '$'
stackarg 4096 (@1)
evaltop @(A,O) 2 1
stackarg 4157 (@0)
0MEMORYADDR0 		staa	OPT2		; disable clk4x & C,G wire-or modes

char 'O'
stackarg 56 (@0)
0MEMORYADDR0 		staa	BPROT		; allow eeprom to be written

char 'B'
stackarg 53 (@0)
0MEMORYADDR0 		ldab	#OPTION_ADPU	; enable ADC

char '#'
char 'O'
stackarg 128 (@0)
0MEMORYADDR0 		stab	OPTION

char 'O'
stackarg 57 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; SETUP PORTS AND DDRS

0MEMORYADDR0 		;

0MEMORYADDR0 		;	    DDR	       DATA

0MEMORYADDR0 		; PORTA	 10000000    0xxxxxxx	(+24V power switch)

0MEMORYADDR0 		; PORTB  <OUTPUT>    11111111	(LED's)

0MEMORYADDR0 		; PORTC  00000000    xxxxxxxx

0MEMORYADDR0 		; PORTD  xx110000    xx00xxxx   (~ss, sck)

0MEMORYADDR0 		; PORTE  <INPUT>     xxxxxxxx	(addr h, l, brdid, temp)

0MEMORYADDR0 		; PORTF  <OUTPUT>    00111111	(digout, LED's)

0MEMORYADDR0 		; PORTG  11111100    000000xx	(filter, mux sel, startconv, 

0MEMORYADDR0 		;				digin)

0MEMORYADDR0 		; note: PD5 must be an output so as not to interfere with

0MEMORYADDR0 		; SPI ~SS hardware.

0MEMORYADDR0 		;

0MEMORYADDR0 		; NOTE: PORTA_24V is off (0) by default.  This is to prevent

0MEMORYADDR0 		; the RTU's isolated power supply from getting jerked around

0MEMORYADDR0 		; when several boards are in the system.  Analog and digital

0MEMORYADDR0 		; inputs will not be valid until the RTU turns on this line.

0MEMORYADDR0 		;

0MEMORYADDR0 		; NOTE: PORTD ~SS output must be set to 1 before configuring

0MEMORYADDR0 		; the SPI as a master (???)

0MEMORYADDR0 		;

0MEMORYADDR0 		; .A is still 0

0MEMORYADDR0 

0MEMORYADDR0 		lds	#DDRD

char '#'
char 'D'
stackarg 9 (@0)
0MEMORYADDR0 		ldab	#%00111000	; DDRD = 00111000

char '#'
char '%'
stackarg 56 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		pshb			; PORTD= 00111000

0MEMORYADDR0 		psha			; DDRC = 00000000

0MEMORYADDR0 		des			; RESERVED06

0MEMORYADDR0 		ldab	#$3F		; PORTF= 00111111

char '#'
char '$'
stackarg 63 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		ldab	#$FF		; PORTB= 11111111

char '#'
char '$'
stackarg 255 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		ldab	#%11111100	; DDRG = 11111100

char '#'
char '%'
stackarg 252 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		psha			; PORTG= 0

0MEMORYADDR0 		ldab	#PORTA_24V	; DDRA = PORTA_24V

char '#'
char 'P'
stackarg 128 (@0)
0MEMORYADDR0 		pshb

0MEMORYADDR0 		psha			; PORTA= 0

0MEMORYADDR0 

0MEMORYADDR0 		; Setup remaining hardware, .A still 0

0MEMORYADDR0 		;

0MEMORYADDR0 		;	ADC	setup for continuous scan channels 4-7

0MEMORYADDR0 		;	SCI	9600bps 8N1, IDLE wake detection

0MEMORYADDR0 		;	SPI	Setup clock phase, etc..

0MEMORYADDR0 

0MEMORYADDR0 		ldab	#ADCTL_MULT|ADCTL_SCAN|ADCTL_CC

char '#'
char 'A'
stackarg 16 (@0)
char '|'
doop
doop @ 0 unary
char 'A'
stackarg 32 (@1)
char '|'
doop
evaltop @(A,O) 2 1
stackarg 48 (@0)
doop @ 0
char 'A'
stackarg 4 (@1)
evaltop @(A,O) 2 1
stackarg 52 (@0)
0MEMORYADDR0 		stab	ADCTL

char 'A'
stackarg 48 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		staa	SCCR1

char 'S'
stackarg 44 (@0)
0MEMORYADDR0 		ldab	#SCCR2_TE|SCCR2_RE

char '#'
char 'S'
stackarg 8 (@0)
char '|'
doop
doop @ 0 unary
char 'S'
stackarg 4 (@1)
evaltop @(A,O) 2 1
stackarg 12 (@0)
0MEMORYADDR0 		stab	SCCR2

char 'S'
stackarg 45 (@0)
0MEMORYADDR0 		ldab	#BAUD_9600

char '#'
char 'B'
stackarg 3 (@0)
0MEMORYADDR0 		stab	BAUD

char 'B'
stackarg 43 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; SPI, .A still 0

0MEMORYADDR0 		;

0MEMORYADDR0 		; CPOL=0, CPHA=0, clkrate= E/2 (614KHz)

0MEMORYADDR0 

0MEMORYADDR0 		ldab	#SPCR_MSTR	; make master, disable

char '#'
char 'S'
stackarg 16 (@0)
0MEMORYADDR0 		stab	SPCR

char 'S'
stackarg 40 (@0)
0MEMORYADDR0 		bset	SPCR,SPCR_SPE	; enable

char 'S'
stackarg 40 (@0)
char ','
char 'S'
stackarg 64 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; ICR - Input capture registers

0MEMORYADDR0 		;

0MEMORYADDR0 		; Setup input capture registers for counter inputs and setup

0MEMORYADDR0 		; OC1 to handle system timing.

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		bset	TCTL2,TCTL2_EDG1A|TCTL2_EDG2A|TCTL2_EDG3A

char 'T'
stackarg 33 (@0)
char ','
char 'T'
stackarg 16 (@0)
char '|'
doop
doop @ 0 unary
char 'T'
stackarg 4 (@1)
char '|'
doop
evaltop @(A,O) 2 1
stackarg 20 (@0)
doop @ 0
char 'T'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 21 (@0)
0MEMORYADDR0 		bset	TMSK1,TMSK1_IC1I|TMSK1_IC2I|TMSK1_OC1I

char 'T'
stackarg 34 (@0)
char ','
char 'T'
stackarg 4 (@0)
char '|'
doop
doop @ 0 unary
char 'T'
stackarg 2 (@1)
char '|'
doop
evaltop @(A,O) 2 1
stackarg 6 (@0)
doop @ 0
char 'T'
stackarg 128 (@1)
evaltop @(A,O) 2 1
stackarg 134 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; bootstrap interrupt vectors (.A still 0)

0MEMORYADDR0 		;

0MEMORYADDR0 		; When bootstrapping to ram, the 68HC11F1 implements pseudo

0MEMORYADDR0 		; vectors and we have to create a jump table for the vectors

0MEMORYADDR0 		; we use.

0MEMORYADDR0 

0MEMORYADDR0 	       ifnconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		ldab	#$7E		; JMP extended instruction

0MEMORYADDR0 		stab	BsOC1Jmp

0MEMORYADDR0 		stab    BsIC1Jmp

0MEMORYADDR0 		stab    BsIC2Jmp

0MEMORYADDR0 		ldx	#OC1Int		; address of OC1 interrupt

0MEMORYADDR0 		stx	BsOC1Jmp+1

0MEMORYADDR0 		ldx	#IC1Int

0MEMORYADDR0 		stx	BsIC1Jmp+1

0MEMORYADDR0 		ldx	#IC2Int

0MEMORYADDR0 		stx	BsIC2Jmp+1

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 		; Setup stack and various ram variables, .A still 0

0MEMORYADDR0 		;

0MEMORYADDR0 		; We do not have to clear RTIWDog since it is reset by packet

0MEMORYADDR0 		; reception and the relays are off anyway before then.  We

0MEMORYADDR0 		; do not have to clear the red/grn count either because the

0MEMORYADDR0 		; l.e.d's are already off.

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		lds	#StackEnd-1	; reset stack pointer

char '#'
char 'S'
stackarg 928 (@0)
char '-'
doop
doop @ 0 unary
char '1'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 927 (@0)
0MEMORYADDR0 		staa	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		staa	RTIAvrCnt

char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		cli			; enable ints (note: stop disble is 1)

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		  MAIN PACKET WAIT LOOP		     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Wait for an incomming packet 

0MEMORYADDR0 		;

0MEMORYADDR0 		; The RED led is lit when an error is detected

0MEMORYADDR0 		;

0MEMORYADDR0 		; The GRN led is lit whenever we receive a valid packet

0MEMORYADDR0 		; whos address is for us.

0MEMORYADDR0 

0MEMORYADDR0 PKT_LEN		equ	0

char '0'
stackarg 0 (@0)
0MEMORYADDR0 PKT_ADR		equ	1

char '1'
stackarg 1 (@0)
0MEMORYADDR0 PKT_CMD		equ	2

char '2'
stackarg 2 (@0)
0MEMORYADDR0 PKT_DATA	equ	3

char '3'
stackarg 3 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 

0MEMORYADDR0 WaitPacketRed	

0MEMORYADDR0 		ldaa	#56		; 3 seconds

char '#'
char '5'
stackarg 56 (@0)
0MEMORYADDR0 		staa	RTIRedCnt

char 'R'
stackarg 102 (@0)
0MEMORYADDR0 		bclr	PORTF,PORTF_RED

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 16 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; Wait for a packet.  We keep a running checksum while

0MEMORYADDR0 		; bringing in the packet and setup the loop such that

0MEMORYADDR0 		; .X will point to the CHK byte when done rather then

0MEMORYADDR0 		; one past the CHK byte.

0MEMORYADDR0 		;

0MEMORYADDR0 		;	AA

0MEMORYADDR0 		;	LEN		\

0MEMORYADDR0 		;	ADR		|

0MEMORYADDR0 		;	CMD		| LEN bytes

0MEMORYADDR0 		;	DATA[LEN-4]	|

0MEMORYADDR0 		;	CHK		/

0MEMORYADDR0 		;	55

0MEMORYADDR0 		;

0MEMORYADDR0 		; CHK does not include AA or 55.  CHK is formulated such

0MEMORYADDR0 		; that it all adds to zero.

0MEMORYADDR0 

0MEMORYADDR0 WaitPacket

0MEMORYADDR0 		bsr	GetB		; get protocol/synch

char 'G'
stackarg 65240 (@0)
0MEMORYADDR0 		cmpb	#$AA		; ignore if not $AA packet

char '#'
char '$'
stackarg 170 (@0)
0MEMORYADDR0 		bne	WaitPacketRed

char 'W'
stackarg 65119 (@0)
0MEMORYADDR0 		clra			; checksum accumulation

0MEMORYADDR0 		ldx	#PacketBuf-1

char '#'
char 'P'
stackarg 107 (@0)
char '-'
doop
doop @ 0 unary
char '1'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 106 (@0)
0MEMORYADDR0 .1		bsr	GetB		; get byte (first byte is length)

char 'G'
stackarg 65240 (@0)
0MEMORYADDR0 		inx

0MEMORYADDR0 		stab	0,x		; store

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		aba			; accumulate checksum

0MEMORYADDR0 		dec	PacketBuf

char 'P'
stackarg 107 (@0)
0MEMORYADDR0 		bne	.1

char '.'
stackarg 65136 (@0)
0MEMORYADDR0 		tsta

0MEMORYADDR0 		bne	WaitPacketRed

char 'W'
stackarg 65119 (@0)
0MEMORYADDR0 		bsr	GetB		; obtain endsynch and check

char 'G'
stackarg 65240 (@0)
0MEMORYADDR0 		cmpb	#$55

char '#'
char '$'
stackarg 85 (@0)
0MEMORYADDR0 		bne	WaitPacketRed

char 'W'
stackarg 65119 (@0)
0MEMORYADDR0 					; check address

0MEMORYADDR0 		ldaa	PacketBuf+PKT_ADR

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 108 (@0)
0MEMORYADDR0 		bmi	.10

char '.'
stackarg 65164 (@0)
0MEMORYADDR0 		cmpa	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 		bne	WaitPacket

char 'W'
stackarg 65126 (@0)
0MEMORYADDR0 .10

0MEMORYADDR0 		; Now have a valid packet, setup for return and

0MEMORYADDR0 		; execute command

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		ldab	PacketBuf+PKT_CMD

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 109 (@0)
0MEMORYADDR0 		ldaa	#22		; aprox set wdog 5 min (sto msb)

char '#'
char '2'
stackarg 22 (@0)
0MEMORYADDR0 		staa	RTIWDog	

char 'R'
stackarg 104 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		ldx	#CommandTable	; lookup the command

char '#'
char 'C'
stackarg 65255 (@0)
0MEMORYADDR0 		andb	#$0E		; force command to be valid

char '#'
char '$'
stackarg 14 (@0)
0MEMORYADDR0 		abx

0MEMORYADDR0 		ldx	0,x		; get pointer to command

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 

0MEMORYADDR0 					; setup part of response

0MEMORYADDR0 		ldaa	#$20

char '#'
char '$'
stackarg 32 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_ADR

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 108 (@0)
0MEMORYADDR0 		ldaa	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_CMD

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 109 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		jsr	0,x		; Execute the command

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		bsr	TransmitPacket

char 'T'
stackarg 65192 (@0)
0MEMORYADDR0 		bra	WaitPacket

char 'W'
stackarg 65126 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; Upon completion transmit back .B bytes of data.. that is,

0MEMORYADDR0 		; a packet:

0MEMORYADDR0 		;    AA LEN ADR+$20 FLG DATA[.B] CHK $55	(LEN=.B+4)

0MEMORYADDR0 

0MEMORYADDR0 TransmitPacket

0MEMORYADDR0 		ldaa	#9		; set green led 0.5 sec

char '#'
char '9'
stackarg 9 (@0)
0MEMORYADDR0 		staa	RTIGrnCnt

char 'R'
stackarg 103 (@0)
0MEMORYADDR0 		bclr	PORTF,PORTF_GRN

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 32 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		addb	#4

char '#'
char '4'
stackarg 4 (@0)
0MEMORYADDR0 		stab	PacketBuf+PKT_LEN

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 0 (@1)
evaltop @(A,O) 2 1
stackarg 107 (@0)
0MEMORYADDR0 		ldx	#PacketBuf

char '#'
char 'P'
stackarg 107 (@0)
0MEMORYADDR0 		clra			; checksum

0MEMORYADDR0 		bclr	SCCR2,SCCR2_RE	; disable receiver

char 'S'
stackarg 45 (@0)
char ','
char 'S'
stackarg 4 (@0)
0MEMORYADDR0 		ldab	#$AA		; sync

char '#'
char '$'
stackarg 170 (@0)
0MEMORYADDR0 .110		bsr	SendB		; send loop, everything except checksum

char 'S'
stackarg 65248 (@0)
0MEMORYADDR0 		ldab	0,x

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		inx

0MEMORYADDR0 		sba

0MEMORYADDR0 		dec	PacketBuf+PKT_LEN

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 0 (@1)
evaltop @(A,O) 2 1
stackarg 107 (@0)
0MEMORYADDR0 		bne	.110

char '.'
stackarg 65212 (@0)
0MEMORYADDR0 		aba

0MEMORYADDR0 		tab			; send checksum

0MEMORYADDR0 		bsr	SendB

char 'S'
stackarg 65248 (@0)
0MEMORYADDR0 		ldab	#$55

char '#'
char '$'
stackarg 85 (@0)
0MEMORYADDR0 		bsr	SendB

char 'S'
stackarg 65248 (@0)
0MEMORYADDR0 .120		brclr	SCSR,SCSR_TC,.120

char 'S'
stackarg 46 (@0)
char ','
char 'S'
stackarg 64 (@0)
char ','
char '.'
stackarg 65231 (@0)
0MEMORYADDR0 		bset	SCCR2,SCCR2_RE	; reenable receiver

char 'S'
stackarg 45 (@0)
char ','
char 'S'
stackarg 4 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		; GETB - receive a character from the serial port

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 GetBLoop	wai

0MEMORYADDR0 GetB 		brclr	SCSR,SCSR_RDRF,GetBLoop

char 'S'
stackarg 46 (@0)
char ','
char 'S'
stackarg 32 (@0)
char ','
char 'G'
stackarg 65239 (@0)
0MEMORYADDR0 		ldab	SCDR

char 'S'
stackarg 47 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		; SENDB - transmit a character to the serial port

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 SendBLoop	wai

0MEMORYADDR0 SendB 		brclr	SCSR,SCSR_TDRE,SendBLoop

char 'S'
stackarg 46 (@0)
char ','
char 'S'
stackarg 128 (@0)
char ','
char 'S'
stackarg 65247 (@0)
0MEMORYADDR0 		stab	SCDR

char 'S'
stackarg 47 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		     	COMMANDS

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		;  A command must return the response length in .B, 0

0MEMORYADDR0 		;  if no data (returns a packet with no data)

0MEMORYADDR0 		;

0MEMORYADDR0 		;  00	IDENTIFY

0MEMORYADDR0 		;  02   READ BYTES

0MEMORYADDR0 		;  04   WRITE BYTES

0MEMORYADDR0 		;  06   PROGRAM EEPROM BYTE

0MEMORYADDR0 		;  08   RESET

0MEMORYADDR0 		;  0A   CONFIGURE

0MEMORYADDR0 		;  0C   BAD CMD

0MEMORYADDR0 		;  0E   BAD CMD

0MEMORYADDR0 

0MEMORYADDR0 CommandTable

0MEMORYADDR0 		dc.w	IdentifyCmd

char 'I'
stackarg 65281 (@0)
0MEMORYADDR0 		dc.w	ReadBytesCmd

char 'R'
stackarg 65296 (@0)
0MEMORYADDR0 		dc.w	WriteBytesCmd

char 'W'
stackarg 65319 (@0)
0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		dc.w	BadCmd

char 'B'
stackarg 65271 (@0)
0MEMORYADDR0 	       else

0MEMORYADDR0 		dc.w	ProgramByteCmd

0MEMORYADDR0 	       eif

0MEMORYADDR0 		dc.w	ResetCmd

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	ConfigureCmd

char 'C'
stackarg 65273 (@0)
0MEMORYADDR0 		dc.w	BadCmd

char 'B'
stackarg 65271 (@0)
0MEMORYADDR0 		dc.w	BadCmd

char 'B'
stackarg 65271 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;  BADCMD

0MEMORYADDR0 		;

0MEMORYADDR0 		;  Bad command, simply ignore... return an empty packet

0MEMORYADDR0 

0MEMORYADDR0 BadCmd		subroutine

0MEMORYADDR0 		clrb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;  CONFIGURECMD

0MEMORYADDR0 		;

0MEMORYADDR0 		;  Configure an I/O board, copy data to RTUConfig and PORTA

0MEMORYADDR0 

0MEMORYADDR0 ConfigureCmd	subroutine

0MEMORYADDR0 		ldd	PacketBuf+PKT_DATA

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		staa	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		stab	PORTA

char 'P'
stackarg 0 (@0)
0MEMORYADDR0 		clrb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;   IDENTIFY	- identify board

0MEMORYADDR0 		;

0MEMORYADDR0 		;   returns board type, board address, board temp, board id

0MEMORYADDR0 		;

0MEMORYADDR0 		;   IdentifyUncCmd only identifies unconfigured boards

0MEMORYADDR0 

0MEMORYADDR0 		subroutine

0MEMORYADDR0 IdentifyCmd

0MEMORYADDR0 		ldaa	#1

char '#'
char '1'
stackarg 1 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_DATA

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		ldaa	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 		staa	PacketBuf+PKT_DATA+1

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '1'
stackarg 1 (@1)
evaltop @(A,O) 2 1
stackarg 111 (@0)
0MEMORYADDR0 		ldd	ADR1

char 'A'
stackarg 49 (@0)
0MEMORYADDR0 		std	PacketBuf+PKT_DATA+2

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '2'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 112 (@0)
0MEMORYADDR0 		ldab	#4

char '#'
char '4'
stackarg 4 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;   READ BYTES - read data bytes

0MEMORYADDR0 		;

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 ReadBytesCmd	subroutine

0MEMORYADDR0 		ldx	PacketBuf+PKT_DATA	; source address

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		ldy	#PacketBuf+PKT_DATA+3	; destination address

char '#'
char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '3'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 113 (@0)
0MEMORYADDR0 memCpy		clrb

0MEMORYADDR0 memCpyLoop	ldaa	0,x

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		staa	0,y

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		inx

0MEMORYADDR0 		iny

0MEMORYADDR0 		incb

0MEMORYADDR0 		cmpb	PacketBuf+PKT_DATA+2

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '2'
stackarg 2 (@1)
evaltop @(A,O) 2 1
stackarg 112 (@0)
0MEMORYADDR0 		bne	memCpyLoop

char 'm'
stackarg 65303 (@0)
0MEMORYADDR0 		addb	#3

char '#'
char '3'
stackarg 3 (@0)
0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;   WRITE BYTES - write data bytes, written data returned

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 WriteBytesCmd	subroutine

0MEMORYADDR0 		ldx	#PacketBuf+PKT_DATA+3	; source address

char '#'
char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
char '+'
doop
evaltop @(A,O) 2 1
stackarg 110 (@0)
doop @ 0
char '3'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 113 (@0)
0MEMORYADDR0 		ldy	PacketBuf+PKT_DATA	; destination address

char 'P'
stackarg 107 (@0)
char '+'
doop
doop @ 0 unary
char 'P'
stackarg 3 (@1)
evaltop @(A,O) 2 1
stackarg 110 (@0)
0MEMORYADDR0 		bra	memCpy

char 'm'
stackarg 65302 (@0)
0MEMORYADDR0 

0MEMORYADDR0 	       ifnconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		;   PROGRAM BYTE - write one byte of data to eeprom

0MEMORYADDR0 		;

0MEMORYADDR0 		;   Command:	addr cmd ADRH ADRL LEN DATA[]

0MEMORYADDR0 		;   Response:	40+X err 

0MEMORYADDR0 

0MEMORYADDR0 ProgramByteCmd	subroutine

0MEMORYADDR0 		ldx	PacketBuf+PKT_DATA	; destination address

0MEMORYADDR0 		ldab	PacketBuf+PKT_DATA+2	; # of bytes to write

0MEMORYADDR0 		ldy	#PacketBuf+PKT_DATA+3	; source address

0MEMORYADDR0 pbloop		pshb

0MEMORYADDR0 		ldab	0,y

0MEMORYADDR0 		bsr	eepromWrite

0MEMORYADDR0 		pulb

0MEMORYADDR0 		inx

0MEMORYADDR0 		iny

0MEMORYADDR0 		decb

0MEMORYADDR0 		bne	pbloop

0MEMORYADDR0 		; clrb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		; eepromWrite - write data in .B to eeprom address .X

0MEMORYADDR0 		;

0MEMORYADDR0 		; .B, .X left alone

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 eepromWrite	subroutine

0MEMORYADDR0 		ldaa	#PPROG_BYTE|PPROG_ERASE|PPROG_EELAT

0MEMORYADDR0 		bsr	.10

0MEMORYADDR0 		ldaa	#PPROG_EELAT

0MEMORYADDR0 .10		staa	PPROG

0MEMORYADDR0 		stab	0,x

0MEMORYADDR0 		bset	PPROG,PPROG_EEPGM

0MEMORYADDR0 

0MEMORYADDR0 		pshb

0MEMORYADDR0 		ldd	TCNT

0MEMORYADDR0 		addd	#12228

0MEMORYADDR0 .11		cpd	TCNT		; D-TCNT

0MEMORYADDR0 		bpl	.11

0MEMORYADDR0 		pulb

0MEMORYADDR0 

0MEMORYADDR0 		clra

0MEMORYADDR0 		staa	PPROG

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 	       eif

0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		   COUNTER INTERRUPTS

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; IC1 - digital input counter 2 

0MEMORYADDR0 		; IC2 - digital input counter 1

0MEMORYADDR0 

0MEMORYADDR0 IC1Int

0MEMORYADDR0 		ldx	Counter2

char 'C'
stackarg 100 (@0)
0MEMORYADDR0 		inx

0MEMORYADDR0 		stx	Counter2

char 'C'
stackarg 100 (@0)
0MEMORYADDR0 		bclr	TFLG1,<~TFLG1_IC1F

char 'T'
stackarg 35 (@0)
char ','
char '<'
doop
doop @ 0 unary
char '~'
doop
doop @ 1 unary
char 'T'
stackarg 4 (@0)
evaltop @(A,O) 1 2
stackarg -5 (@0)
evaltop @(A,O) 1 1
stackarg 251 (@0)
0MEMORYADDR0 		rti

0MEMORYADDR0 

0MEMORYADDR0 IC2Int

0MEMORYADDR0 		ldx	Counter1

char 'C'
stackarg 98 (@0)
0MEMORYADDR0 		inx

0MEMORYADDR0 		stx	Counter1

char 'C'
stackarg 98 (@0)
0MEMORYADDR0 		bclr	TFLG1,<~TFLG1_IC2F

char 'T'
stackarg 35 (@0)
char ','
char '<'
doop
doop @ 0 unary
char '~'
doop
doop @ 1 unary
char 'T'
stackarg 2 (@0)
evaltop @(A,O) 1 2
stackarg -3 (@0)
evaltop @(A,O) 1 1
stackarg 253 (@0)
0MEMORYADDR0 		rti

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		     GET BOARD ADDRESS		     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; GetBoardAddr - calculate board network address 00-0F

0MEMORYADDR0 		;		 and return in .B

0MEMORYADDR0 		;

0MEMORYADDR0 		;	ADR4 (msb) and ADR3 (lsb) contain the address.  

0MEMORYADDR0 		;	Each A/D is valued as shown below.  We conver the

0MEMORYADDR0 		;	A/D value to a two bit address simply by multiplying

0MEMORYADDR0 		;	it by x3 and extracting the top two bits.  The

0MEMORYADDR0 		;	result is also flexible enough to allow variations in

0MEMORYADDR0 		;	ADC values.

0MEMORYADDR0 		;

0MEMORYADDR0 		;		**xxxxxx

0MEMORYADDR0 		;

0MEMORYADDR0 		; 00 x 3 =  00  00000000

0MEMORYADDR0 		; 1E x 3 =  5A  01011010

0MEMORYADDR0 		; 37 x 3 =  A5  10100101

0MEMORYADDR0 		; 4B x 3 =  E1  11100001

0MEMORYADDR0 

0MEMORYADDR0 GetBoardAddr	subroutine

0MEMORYADDR0 		clrb			; address accumulator

0MEMORYADDR0 		ldaa	ADR4

char 'A'
stackarg 52 (@0)
0MEMORYADDR0 		bsr	oneOfFour

char 'o'
stackarg 65352 (@0)
0MEMORYADDR0 		ldaa	ADR3

char 'A'
stackarg 51 (@0)
0MEMORYADDR0 oneOfFour

0MEMORYADDR0 		pshb

0MEMORYADDR0 		tab

0MEMORYADDR0 		asla

0MEMORYADDR0 		aba

0MEMORYADDR0 		pulb

0MEMORYADDR0 

0MEMORYADDR0 		asla

0MEMORYADDR0 		rolb

0MEMORYADDR0 		asla

0MEMORYADDR0 		rolb

0MEMORYADDR0 		rts

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		     OC1 INTERRUPT

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; The OC1 interrupt is set to occur at 3840Hz (~260uS).  Each

0MEMORYADDR0 		; interrupt switches channel so each individual channel is

0MEMORYADDR0 		; effectively sampled at 240Hz.  256 samples are accumulated

0MEMORYADDR0 		; yielding a 20 bit sum which is normalized to 16 bits and

0MEMORYADDR0 		; transfered to another ram address for reading by the RTU.

0MEMORYADDR0 		;

0MEMORYADDR0 		; Working the math, you will also notice that 256 samples at

0MEMORYADDR0 		; 240 Hz winds up being an integral number of 60Hz cycles,

0MEMORYADDR0 		; therefore any 60Hz hum (and most harmonics of 60Hz) are 

0MEMORYADDR0 		; automatically removed.

0MEMORYADDR0 		;

0MEMORYADDR0 		; The OC1 interrupt also serves the following functions:

0MEMORYADDR0 		;    * Break WAI instruction in main loop for serial poll

0MEMORYADDR0 		;    * Handle LEDs and watchdog countdown

0MEMORYADDR0 		;    * Ensure processor runs long enough for ADC to convert

0MEMORYADDR0 

0MEMORYADDR0 OC1Int		subroutine

0MEMORYADDR0 

0MEMORYADDR0 		; 1.2288MHzx320 (3840Hz) Max176 scan

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 

0MEMORYADDR0 		ldab	PORTG

char 'P'
stackarg 2 (@0)
0MEMORYADDR0 		lsrb

0MEMORYADDR0 		lsrb

0MEMORYADDR0 		ldx	#MaxScanTable	; +0 primary, +32 acclsb, +64 accmsb

char '#'
char 'M'
stackarg 768 (@0)
0MEMORYADDR0 		abx

0MEMORYADDR0 		bsr	ScanMax16	; fmt ssdddddd.ddddddxx

char 'S'
stackarg 65472 (@0)
0MEMORYADDR0 		andb	#$FC

char '#'
char '$'
stackarg 252 (@0)
0MEMORYADDR0 		aslb

0MEMORYADDR0 		rola

0MEMORYADDR0 		aslb

0MEMORYADDR0 		rola			

0MEMORYADDR0 		bcc	.4		; if negative, msb is all 1's

char '.'
stackarg 65382 (@0)
0MEMORYADDR0 		dec	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 .4		addd	32,x		; fmt dddddddd.dddd0000

char '3'
stackarg 32 (@0)
char ','
0MEMORYADDR0 		bcc	.5		; carry

char '.'
stackarg 65388 (@0)
0MEMORYADDR0 		inc	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 .5		tst	RTIAvrCnt

char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		bne	.10		; fmt 0ddddddd.dddddddd.dddd0000

char '.'
stackarg 65405 (@0)
0MEMORYADDR0 		aslb			; cvt to dddddddd.dddddddd

0MEMORYADDR0 		tab

0MEMORYADDR0 		rolb

0MEMORYADDR0 		ldaa	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 		rola

0MEMORYADDR0 		std	0,x

char '0'
stackarg 0 (@0)
char ','
0MEMORYADDR0 		clra			; setup to clear msb, lsb

0MEMORYADDR0 		clrb

0MEMORYADDR0 		staa	64,x

char '6'
stackarg 64 (@0)
char ','
0MEMORYADDR0 .10		std	32,x

char '3'
stackarg 32 (@0)
char ','
0MEMORYADDR0 		ldab	PORTG

char 'P'
stackarg 2 (@0)
0MEMORYADDR0 		addb	#$08

char '#'
char '$'
stackarg 8 (@0)
0MEMORYADDR0 		bpl	.20

char '.'
stackarg 65420 (@0)
0MEMORYADDR0 		ldaa	RTIAvrCnt

char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		adda	#$02		; $10=16 samp/avr, $02=128 samp avr

char '#'
char '$'
stackarg 2 (@0)
0MEMORYADDR0 		staa	RTIAvrCnt

char 'R'
stackarg 106 (@0)
0MEMORYADDR0 		clrb

0MEMORYADDR0 .20		stab	PORTG

char 'P'
stackarg 2 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; Setup for next interrupt

0MEMORYADDR0 		;

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		bclr	TFLG1,<~TFLG1_OC1F

char 'T'
stackarg 35 (@0)
char ','
char '<'
doop
doop @ 0 unary
char '~'
doop
doop @ 1 unary
char 'T'
stackarg 128 (@0)
evaltop @(A,O) 1 2
stackarg -129 (@0)
evaltop @(A,O) 1 1
stackarg 127 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		ldd	TOC1

char 'T'
stackarg 22 (@0)
0MEMORYADDR0 		addd	#320

char '#'
char '3'
stackarg 320 (@0)
0MEMORYADDR0 		std	TOC1

char 'T'
stackarg 22 (@0)
0MEMORYADDR0 		bcc	.200

char '.'
stackarg 65471 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		; x65536 (18.75 Hz) code

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 		dec	RTIRedCnt

char 'R'
stackarg 102 (@0)
0MEMORYADDR0 		bne	.100

char '.'
stackarg 65442 (@0)
0MEMORYADDR0 		bset	PORTF,PORTF_RED

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 16 (@0)
0MEMORYADDR0 .100		

0MEMORYADDR0 		dec	RTIGrnCnt

char 'R'
stackarg 103 (@0)
0MEMORYADDR0 		bne	.101

char '.'
stackarg 65450 (@0)
0MEMORYADDR0 		bset	PORTF,PORTF_GRN

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 32 (@0)
0MEMORYADDR0 .101		

0MEMORYADDR0 		ldx	RTIWDog

char 'R'
stackarg 104 (@0)
0MEMORYADDR0 		dex

0MEMORYADDR0 		stx	RTIWDog

char 'R'
stackarg 104 (@0)
0MEMORYADDR0 		beq	.102r

char '.'
stackarg 65465 (@0)
0MEMORYADDR0 .102

0MEMORYADDR0 		bsr	GetBoardAddr	; obtain board address

char 'G'
stackarg 65345 (@0)
0MEMORYADDR0 		cmpb	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 		beq	.103

char '.'
stackarg 65471 (@0)
0MEMORYADDR0 		stab	BoardAddr

char 'B'
stackarg 97 (@0)
0MEMORYADDR0 .102r

0MEMORYADDR0 		clr	RTUConfig

char 'R'
stackarg 96 (@0)
0MEMORYADDR0 		bclr	PORTF,PORTF_DIGOUT1|PORTF_DIGOUT2

char 'P'
stackarg 5 (@0)
char ','
char 'P'
stackarg 64 (@0)
char '|'
doop
doop @ 0 unary
char 'P'
stackarg 128 (@1)
evaltop @(A,O) 2 1
stackarg 192 (@0)
0MEMORYADDR0 .103

0MEMORYADDR0 

0MEMORYADDR0 		;

0MEMORYADDR0 		;

0MEMORYADDR0 

0MEMORYADDR0 .200		

0MEMORYADDR0 		rti

0MEMORYADDR0 

0MEMORYADDR0 		; SCANMAX16 - scan Max176

0MEMORYADDR0 		;

0MEMORYADDR0 		; This routine may not be interrupted due to sample-and-hold

0MEMORYADDR0 		; droop in the Max176.  We use the SPI to generate 16 clocks

0MEMORYADDR0 		; to the Max176 after the rising edge of strobe.  The falling

0MEMORYADDR0 		; edge of strobe must occur before the 12th bit and can occur

0MEMORYADDR0 		; as soon as the second bit.

0MEMORYADDR0 

0MEMORYADDR0 ScanMax16	subroutine

0MEMORYADDR0 		bset	PORTG,PORTG_ADSTROBHI

char 'P'
stackarg 2 (@0)
char ','
char 'P'
stackarg 4 (@0)
0MEMORYADDR0 		bsr	Get8B			; 13 from store

char 'G'
stackarg 65483 (@0)
0MEMORYADDR0 		bsr	Get8A			; 16 to load, 13 from store

char 'G'
stackarg 65479 (@0)
0MEMORYADDR0 Get8A		bclr	PORTG,PORTG_ADSTROBHI	; 6

char 'P'
stackarg 2 (@0)
char ','
char 'P'
stackarg 4 (@0)
0MEMORYADDR0 		tba				; 2

0MEMORYADDR0 Get8B		tst	SPSR			; 3

char 'S'
stackarg 41 (@0)
0MEMORYADDR0 		ldab	SPDR			; 3

char 'S'
stackarg 42 (@0)
0MEMORYADDR0 		stab	SPDR			; 3

char 'S'
stackarg 42 (@0)
0MEMORYADDR0 		asla				; 2

0MEMORYADDR0 		asla				; 2

0MEMORYADDR0 		asra				; 2

0MEMORYADDR0 		asra				; 2

0MEMORYADDR0 		rts				; 5

0MEMORYADDR0 

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;		    INTERRUPT VECTORS	     	     -

0MEMORYADDR0 		;-----------------------------------------------------

0MEMORYADDR0 		;

0MEMORYADDR0 		; Interrupt Vectors

0MEMORYADDR0 		;

0MEMORYADDR0 		; note: if we need the space we can use some of this space

0MEMORYADDR0 		; for code (for those interrupt vectors we do not use)

0MEMORYADDR0 

0MEMORYADDR0 	       ifconst INEEPROM

char 'I'
stackarg 0 (@0)
0MEMORYADDR0 		org	$FFD6+9*2

char '$'
stackarg 65494 (@0)
char '+'
doop
doop @ 0 unary
char '9'
stackarg 9 (@1)
char '*'
doop
doop @ 1
char '2'
stackarg 2 (@2)
evaltop @(A,O) 3 2
stackarg 18 (@1)
evaltop @(A,O) 2 1
stackarg 65512 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		;;dc.w	BadInt		; SCI serial

0MEMORYADDR0 		;;dc.w	BadInt		; SPIE

0MEMORYADDR0 		;;dc.w	BadInt		; PAII Pulse Accumulator

0MEMORYADDR0 		;;dc.w	BadInt		; PAOVI Pulse Accumulator Overflow

0MEMORYADDR0 		;;dc.w	BadInt		; TOI Timer overflow

0MEMORYADDR0 		;;dc.w	BadInt		; OC5

0MEMORYADDR0 		;;dc.w	BadInt		; OC4

0MEMORYADDR0 		;;dc.w	BadInt		; OC3

0MEMORYADDR0 		;;dc.w	BadInt		; OC2

0MEMORYADDR0 		dc.w	OC1Int		; OC1

char 'O'
stackarg 65362 (@0)
0MEMORYADDR0 		dc.w	BadInt		; IC3

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	IC2Int		; IC2

char 'I'
stackarg 65336 (@0)
0MEMORYADDR0 		dc.w	IC1Int		; IC1

char 'I'
stackarg 65327 (@0)
0MEMORYADDR0 

0MEMORYADDR0 		dc.w	BadInt		; RTI Realtime interrupt

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	BadInt		; IRQ

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	BadInt		; XIRQ

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	BadInt		; SWI

char 'B'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; Illegal OpCode Trap

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; COP failure (reset)

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; Clock Monitor Failure

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 		dc.w	Reset		; RESET

char 'R'
stackarg 65048 (@0)
0MEMORYADDR0 

0MEMORYADDR0 	       eif

0MEMORYADDR0 


Complete.
